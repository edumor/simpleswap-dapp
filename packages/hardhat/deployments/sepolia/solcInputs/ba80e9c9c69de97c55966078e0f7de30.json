{
  "language": "Solidity",
  "sources": {
    "contracts/SimpleSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title SimpleSwap\r\n * @notice An optimized automated market maker (AMM) for token swapping without fees\r\n * @dev Implements constant product formula x * y = k without any fees using structs for gas optimization.\r\n * This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.\r\n * @author Eduardo Moreno - Optimized Version\r\n * @custom:security-contact eduardomoreno2503@gmail.com\r\n */\r\ncontract SimpleSwap {\r\n\r\n    /// @notice Struct to store all reserve and liquidity data for a trading pair\r\n    /// @dev Packs related data together to minimize storage slots and gas costs\r\n    struct PairData {\r\n        uint256 reserveA;           /// @dev Reserve amount of tokenA in the pair\r\n        uint256 reserveB;           /// @dev Reserve amount of tokenB in the pair  \r\n        uint256 totalLiquidity;     /// @dev Total liquidity tokens issued for this pair\r\n    }\r\n\r\n    /// @notice Struct to cache storage values during function execution\r\n    /// @dev Used to minimize storage reads/writes within functions by loading data once\r\n    struct LocalPairData {\r\n        uint256 reserveA;           /// @dev Local cache of tokenA reserve\r\n        uint256 reserveB;           /// @dev Local cache of tokenB reserve\r\n        uint256 totalLiquidity;     /// @dev Local cache of total liquidity\r\n        bool isFirstProvision;      /// @dev Flag indicating if this is the first liquidity provision\r\n    }\r\n\r\n    /// @notice Maps a deterministic token pair hash to its PairData\r\n    /// @dev Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering\r\n    /// to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order\r\n    mapping(bytes32 => PairData) public pairs;\r\n\r\n    /// @notice Stores liquidity token balances for each user in each pair\r\n    /// @dev Maps pair hash => user address => liquidity balance\r\n    mapping(bytes32 => mapping(address => uint256)) public liquidityBalances;\r\n\r\n    /// @notice Emitted when tokens are swapped\r\n    /// @param tokenIn The address of the token sent into the swap\r\n    /// @param tokenOut The address of the token received from the swap\r\n    /// @param amountIn The amount of tokenIn that was swapped\r\n    /// @param amountOut The amount of tokenOut that was received\r\n    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\r\n\r\n    /// @notice Emitted when liquidity is added or removed from a pair\r\n    /// @param tokenA The address of the first token in the pair\r\n    /// @param tokenB The address of the second token in the pair\r\n    /// @param amountA The amount of tokenA involved in the liquidity action\r\n    /// @param amountB The amount of tokenB involved in the liquidity action\r\n    /// @param liquidity The amount of liquidity tokens minted (if added) or burned (if removed)\r\n    /// @param isAdded True if liquidity was added, false if removed\r\n    event LiquidityAction(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB, uint256 liquidity, bool isAdded);\r\n\r\n    /**\r\n     * @notice Internal function to get a deterministic hash for a token pair\r\n     * @dev Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing\r\n     * to guarantee the same hash for (A, B) and (B, A)\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @return pairHash The keccak256 hash of the ordered token addresses\r\n     * @return reversed True if tokenA and tokenB were reversed to maintain order, false otherwise\r\n     */\r\n    function _getPairHash(address tokenA, address tokenB) public pure returns (bytes32 pairHash, bool reversed) {\r\n        if (tokenA < tokenB) {\r\n            return (keccak256(abi.encodePacked(tokenA, tokenB)), false);\r\n        } else {\r\n            return (keccak256(abi.encodePacked(tokenB, tokenA)), true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to load pair data from storage into a LocalPairData struct\r\n     * @dev Reads all relevant pair data in a single storage access to minimize gas costs\r\n     * Handles token order reversal for consistent data loading\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @return localData A LocalPairData struct containing the reserves, total liquidity, and first provision status\r\n     * @return pairHash The deterministic hash of the token pair\r\n     * @return reversed True if tokenA and tokenB were reversed during hash calculation\r\n     */\r\n    function _loadPairData(address tokenA, address tokenB) internal view returns (LocalPairData memory localData, bytes32 pairHash, bool reversed) {\r\n        (pairHash, reversed) = _getPairHash(tokenA, tokenB);\r\n        PairData storage pairData = pairs[pairHash]; // Single storage read\r\n\r\n        // Populate localData based on original or reversed order\r\n        if (reversed) {\r\n            localData = LocalPairData({\r\n                reserveA: pairData.reserveB,\r\n                reserveB: pairData.reserveA,\r\n                totalLiquidity: pairData.totalLiquidity,\r\n                isFirstProvision: pairData.totalLiquidity == 0\r\n            });\r\n        } else {\r\n            localData = LocalPairData({\r\n                reserveA: pairData.reserveA,\r\n                reserveB: pairData.reserveB,\r\n                totalLiquidity: pairData.totalLiquidity,\r\n                isFirstProvision: pairData.totalLiquidity == 0\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to save updated pair data from a LocalPairData struct to storage\r\n     * @dev Updates all relevant pair data in a single storage write to minimize gas costs\r\n     * Handles token order reversal to save data consistently\r\n     * @param pairHash The deterministic hash of the token pair\r\n     * @param reversed True if tokenA and tokenB were reversed during hash calculation\r\n     * @param localData A LocalPairData struct containing the updated reserves and total liquidity\r\n     */\r\n    function _savePairData(bytes32 pairHash, bool reversed, LocalPairData memory localData) internal {\r\n        PairData storage pairData = pairs[pairHash]; // Single storage write\r\n        \r\n        // Save data back to storage, respecting the original order\r\n        if (reversed) {\r\n            pairData.reserveA = localData.reserveB;\r\n            pairData.reserveB = localData.reserveA;\r\n        } else {\r\n            pairData.reserveA = localData.reserveA;\r\n            pairData.reserveB = localData.reserveB;\r\n        }\r\n        pairData.totalLiquidity = localData.totalLiquidity;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to calculate the amount of liquidity tokens to mint\r\n     * @dev For the first liquidity provision, it uses the square root of the product of amounts\r\n     * For subsequent provisions, it calculates the proportional liquidity based on existing reserves\r\n     * @param amountA The amount of the first token being added\r\n     * @param amountB The amount of the second token being added\r\n     * @param localData The current LocalPairData containing reserves and total liquidity\r\n     * @return The calculated amount of liquidity tokens to mint\r\n     */\r\n    function _calculateLiquidity(\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        LocalPairData memory localData\r\n    ) internal pure returns (uint256) {\r\n        if (localData.isFirstProvision) {\r\n            // First liquidity provision: liquidity is sqrt(amountA * amountB)\r\n            return _sqrt(amountA * amountB);\r\n        }\r\n        // Subsequent liquidity provision: calculate proportional liquidity\r\n        return _min(\r\n            (amountA * localData.totalLiquidity) / localData.reserveA,\r\n            (amountB * localData.totalLiquidity) / localData.reserveB\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Adds liquidity to a token pair pool\r\n     * @dev Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract,\r\n     * calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event\r\n     * Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @param amountADesired Amount of first token to add\r\n     * @param amountBDesired Amount of second token to add\r\n     * @param amountAMin Minimum amount of first token to add, to prevent front-running\r\n     * @param amountBMin Minimum amount of second token to add, to prevent front-running\r\n     * @param to Address that will receive the liquidity tokens\r\n     * @param deadline Maximum timestamp until which the transaction is valid\r\n     * @return amountA The actual amount of first token added\r\n     * @return amountB The actual amount of second token added\r\n     * @return liquidity The amount of liquidity tokens minted\r\n     */\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\r\n        require(block.timestamp <= deadline, \"expired\");\r\n        require(amountADesired >= amountAMin && amountBDesired >= amountBMin, \"min amt\");\r\n\r\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\r\n        \r\n        liquidity = _calculateLiquidity(amountADesired, amountBDesired, data);\r\n\r\n        _transferFrom(tokenA, msg.sender, address(this), amountADesired);\r\n        _transferFrom(tokenB, msg.sender, address(this), amountBDesired);\r\n\r\n        // Update reserves and total liquidity in local data\r\n        data.reserveA += amountADesired;\r\n        data.reserveB += amountBDesired;\r\n        data.totalLiquidity += liquidity;\r\n\r\n        _savePairData(hash, rev, data);\r\n        liquidityBalances[hash][to] += liquidity;\r\n\r\n        emit LiquidityAction(tokenA, tokenB, amountADesired, amountBDesired, liquidity, true);\r\n        return (amountADesired, amountBDesired, liquidity);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes liquidity from a token pair pool\r\n     * @dev Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB`\r\n     * back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event\r\n     * Requires the received amounts to be at least `amountAMin` and `amountBMin`\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @param liquidity Amount of liquidity tokens to burn\r\n     * @param amountAMin Minimum amount of first token to receive, to prevent front-running\r\n     * @param amountBMin Minimum amount of second token to receive, to prevent front-running\r\n     * @param to Address that will receive the tokens\r\n     * @param deadline Maximum timestamp until which the transaction is valid\r\n     * @return amountA The actual amount of first token returned\r\n     * @return amountB The actual amount of second token returned\r\n     */\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB) {\r\n        require(block.timestamp <= deadline, \"expired\");\r\n        \r\n        // Load data once to check liquidity balance before further calculations\r\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\r\n        require(liquidityBalances[hash][msg.sender] >= liquidity, \"insuf liq\");\r\n\r\n        amountA = (liquidity * data.reserveA) / data.totalLiquidity;\r\n        amountB = (liquidity * data.reserveB) / data.totalLiquidity;\r\n        require(amountA >= amountAMin && amountB >= amountBMin, \"min amt\");\r\n\r\n        // Update reserves and total liquidity in local data\r\n        data.reserveA -= amountA;\r\n        data.reserveB -= amountB;\r\n        data.totalLiquidity -= liquidity;\r\n\r\n        _savePairData(hash, rev, data);\r\n        liquidityBalances[hash][msg.sender] -= liquidity;\r\n\r\n        _transfer(tokenA, to, amountA);\r\n        _transfer(tokenB, to, amountB);\r\n\r\n        emit LiquidityAction(tokenA, tokenB, amountA, amountB, liquidity, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps an exact amount of input tokens for output tokens\r\n     * @dev Transfers `amountIn` of `path[0]` from `msg.sender` to the contract,\r\n     * calculates the output amount of `path[1]`, transfers `amountOut` to `to` address,\r\n     * updates reserves, and emits a `Swap` event\r\n     * Requires `amountOut` to be at least `amountOutMin`\r\n     * @param amountIn Amount of input tokens to swap\r\n     * @param amountOutMin Minimum amount of output tokens to receive, to prevent front-running\r\n     * @param path Array containing [tokenIn, tokenOut] addresses\r\n     * @param to Address that will receive the output tokens\r\n     * @param deadline Maximum timestamp until which the transaction is valid\r\n     */\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external {\r\n        require(block.timestamp <= deadline, \"expired\");\r\n        require(path.length == 2, \"bad path\");\r\n\r\n        // Load data once\r\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(path[0], path[1]);\r\n        \r\n        // Load pair data and calculate output without any fees\r\n\r\n\r\n\r\n        // No fees applied - using direct amountIn for AMM calculation\r\n\r\n        uint256 amountOut = getAmountOut(amountIn, data.reserveA, data.reserveB);\r\n        require(amountOut >= amountOutMin, \"min out\");\r\n\r\n        _transferFrom(path[0], msg.sender, address(this), amountIn);\r\n\r\n        // Update reserves in local data\r\n        data.reserveA += amountIn; // Add input amount to reserves\r\n        data.reserveB -= amountOut;\r\n\r\n        _savePairData(hash, rev, data);\r\n        _transfer(path[1], to, amountOut);\r\n\r\n        emit Swap(path[0], path[1], amountIn, amountOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current price of tokenA in terms of tokenB\r\n     * @dev Calculates the price based on the current reserves of the pair\r\n     * The price is returned as a fixed-point number with 18 decimal places (wei equivalent)\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @return price Price of tokenA in terms of tokenB, scaled by 1e18\r\n     */\r\n    function getPrice(address tokenA, address tokenB) external view returns (uint256 price) {\r\n        (LocalPairData memory data,,) = _loadPairData(tokenA, tokenB);\r\n        // Ensure reserves are not zero to prevent division by zero\r\n        require(data.reserveA > 0, \"zero reserve\");\r\n        return (data.reserveB * 1e18) / data.reserveA;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current reserve amounts for a token pair\r\n     * @dev Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair\r\n     * @param tokenA Address of the first token\r\n     * @param tokenB Address of the second token\r\n     * @return reserveA The current reserve amount of the first token\r\n     * @return reserveB The current reserve amount of the second token\r\n     */\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB) {\r\n        (LocalPairData memory data,,) = _loadPairData(tokenA, tokenB);\r\n        return (data.reserveA, data.reserveB);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the output amount for a swap given an input amount and current reserves\r\n     * @dev Implements the constant product formula (x * y = k) to determine the amount of output tokens\r\n     * received for a given amount of input tokens\r\n     * @param amountIn Amount of input tokens\r\n     * @param reserveIn Reserve of the input token\r\n     * @param reserveOut Reserve of the output token\r\n     * @return amountOut Amount of output tokens to receive\r\n     */\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public pure returns (uint256) {\r\n        require(amountIn > 0, \"bad amt\");\r\n        require(reserveIn > 0, \"bad amt\");\r\n        require(reserveOut > 0, \"bad amt\");\r\n        return (amountIn * reserveOut) / (reserveIn + amountIn);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle `transferFrom` operations for ERC-20 tokens\r\n     * Assumes the `token` address is a valid ERC-20 contract\r\n     * @param token The address of the ERC-20 token contract\r\n     * @param from The address from which tokens are transferred\r\n     * @param to The address to which tokens are transferred\r\n     * @param amount The amount of tokens to transfer\r\n     */\r\n    function _transferFrom(address token, address from, address to, uint256 amount) internal {\r\n        (bool success,) = token.call(\r\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, amount)\r\n        );\r\n        require(success, \"tf fail\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle `transfer` operations for ERC-20 tokens\r\n     * Assumes the `token` address is a valid ERC-20 contract\r\n     * @param token The address of the ERC-20 token contract\r\n     * @param to The address to which tokens are transferred\r\n     * @param amount The amount of tokens to transfer\r\n     */\r\n    function _transfer(address token, address to, uint256 amount) internal {\r\n        (bool success,) = token.call(\r\n            abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount)\r\n        );\r\n        require(success, \"t fail\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to calculate the integer square root of a number\r\n     * Used for initial liquidity calculation\r\n     * @param y The number for which to calculate the square root\r\n     * @return z The integer square root of y\r\n     */\r\n    function _sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to return the minimum of two unsigned integers\r\n     * @param x The first number\r\n     * @param y The second number\r\n     * @return The smaller of x and y\r\n     */\r\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x < y ? x : y;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}