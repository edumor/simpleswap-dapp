{
  "address": "0x93Aa1766Cf4a79267634F2E8669a1c87518791c5",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isAdded",
          "type": "bool"
        }
      ],
      "name": "LiquidityAction",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "Swap",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "_getPairHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "pairHash",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "reversed",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountADesired",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBDesired",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountAMin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBMin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "addLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveOut",
          "type": "uint256"
        }
      ],
      "name": "getAmountOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getReserves",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveB",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "liquidityBalances",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "pairs",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveB",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalLiquidity",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountAMin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBMin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "removeLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "swapExactTokensForTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4723bd71d63d1db88dc67e89a7648144ca81894048b9aa5719d51d693fafd357",
  "receipt": {
    "to": null,
    "from": "0x4829f4f3aadee47Cb1cc795B2eC78A166042e918",
    "contractAddress": "0x93Aa1766Cf4a79267634F2E8669a1c87518791c5",
    "transactionIndex": 123,
    "gasUsed": "991061",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x77d75abd1505a4413b2d1ecddb585d2bd57461fe5a3de84d85c1361434b6ccb4",
    "transactionHash": "0x4723bd71d63d1db88dc67e89a7648144ca81894048b9aa5719d51d693fafd357",
    "logs": [],
    "blockNumber": 8778300,
    "cumulativeGasUsed": "18470869",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ba80e9c9c69de97c55966078e0f7de30",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdded\",\"type\":\"bool\"}],\"name\":\"LiquidityAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"_getPairHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"reversed\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLiquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Eduardo Moreno - Optimized Version\",\"custom:security-contact\":\"eduardomoreno2503@gmail.com\",\"details\":\"Implements constant product formula x * y = k without any fees using structs for gas optimization. This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.\",\"events\":{\"LiquidityAction(address,address,uint256,uint256,uint256,bool)\":{\"params\":{\"amountA\":\"The amount of tokenA involved in the liquidity action\",\"amountB\":\"The amount of tokenB involved in the liquidity action\",\"isAdded\":\"True if liquidity was added, false if removed\",\"liquidity\":\"The amount of liquidity tokens minted (if added) or burned (if removed)\",\"tokenA\":\"The address of the first token in the pair\",\"tokenB\":\"The address of the second token in the pair\"}},\"Swap(address,address,uint256,uint256)\":{\"params\":{\"amountIn\":\"The amount of tokenIn that was swapped\",\"amountOut\":\"The amount of tokenOut that was received\",\"tokenIn\":\"The address of the token sent into the swap\",\"tokenOut\":\"The address of the token received from the swap\"}}},\"kind\":\"dev\",\"methods\":{\"_getPairHash(address,address)\":{\"details\":\"Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing to guarantee the same hash for (A, B) and (B, A)\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"pairHash\":\"The keccak256 hash of the ordered token addresses\",\"reversed\":\"True if tokenA and tokenB were reversed to maintain order, false otherwise\"}},\"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)\":{\"details\":\"Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract, calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively\",\"params\":{\"amountADesired\":\"Amount of first token to add\",\"amountAMin\":\"Minimum amount of first token to add, to prevent front-running\",\"amountBDesired\":\"Amount of second token to add\",\"amountBMin\":\"Minimum amount of second token to add, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"to\":\"Address that will receive the liquidity tokens\",\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"amountA\":\"The actual amount of first token added\",\"amountB\":\"The actual amount of second token added\",\"liquidity\":\"The amount of liquidity tokens minted\"}},\"getAmountOut(uint256,uint256,uint256)\":{\"details\":\"Implements the constant product formula (x * y = k) to determine the amount of output tokens received for a given amount of input tokens\",\"params\":{\"amountIn\":\"Amount of input tokens\",\"reserveIn\":\"Reserve of the input token\",\"reserveOut\":\"Reserve of the output token\"},\"returns\":{\"_0\":\"amountOut Amount of output tokens to receive\"}},\"getPrice(address,address)\":{\"details\":\"Calculates the price based on the current reserves of the pair The price is returned as a fixed-point number with 18 decimal places (wei equivalent)\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"price\":\"Price of tokenA in terms of tokenB, scaled by 1e18\"}},\"getReserves(address,address)\":{\"details\":\"Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"reserveA\":\"The current reserve amount of the first token\",\"reserveB\":\"The current reserve amount of the second token\"}},\"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)\":{\"details\":\"Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB` back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event Requires the received amounts to be at least `amountAMin` and `amountBMin`\",\"params\":{\"amountAMin\":\"Minimum amount of first token to receive, to prevent front-running\",\"amountBMin\":\"Minimum amount of second token to receive, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"liquidity\":\"Amount of liquidity tokens to burn\",\"to\":\"Address that will receive the tokens\",\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"amountA\":\"The actual amount of first token returned\",\"amountB\":\"The actual amount of second token returned\"}},\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\":{\"details\":\"Transfers `amountIn` of `path[0]` from `msg.sender` to the contract, calculates the output amount of `path[1]`, transfers `amountOut` to `to` address, updates reserves, and emits a `Swap` event Requires `amountOut` to be at least `amountOutMin`\",\"params\":{\"amountIn\":\"Amount of input tokens to swap\",\"amountOutMin\":\"Minimum amount of output tokens to receive, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"path\":\"Array containing [tokenIn, tokenOut] addresses\",\"to\":\"Address that will receive the output tokens\"}}},\"stateVariables\":{\"liquidityBalances\":{\"details\":\"Maps pair hash => user address => liquidity balance\"},\"pairs\":{\"details\":\"Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order\"}},\"title\":\"SimpleSwap\",\"version\":1},\"userdoc\":{\"events\":{\"LiquidityAction(address,address,uint256,uint256,uint256,bool)\":{\"notice\":\"Emitted when liquidity is added or removed from a pair\"},\"Swap(address,address,uint256,uint256)\":{\"notice\":\"Emitted when tokens are swapped\"}},\"kind\":\"user\",\"methods\":{\"_getPairHash(address,address)\":{\"notice\":\"Internal function to get a deterministic hash for a token pair\"},\"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)\":{\"notice\":\"Adds liquidity to a token pair pool\"},\"getAmountOut(uint256,uint256,uint256)\":{\"notice\":\"Calculates the output amount for a swap given an input amount and current reserves\"},\"getPrice(address,address)\":{\"notice\":\"Gets the current price of tokenA in terms of tokenB\"},\"getReserves(address,address)\":{\"notice\":\"Gets the current reserve amounts for a token pair\"},\"liquidityBalances(bytes32,address)\":{\"notice\":\"Stores liquidity token balances for each user in each pair\"},\"pairs(bytes32)\":{\"notice\":\"Maps a deterministic token pair hash to its PairData\"},\"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)\":{\"notice\":\"Removes liquidity from a token pair pool\"},\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\":{\"notice\":\"Swaps an exact amount of input tokens for output tokens\"}},\"notice\":\"An optimized automated market maker (AMM) for token swapping without fees\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SimpleSwap.sol\":\"SimpleSwap\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/SimpleSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @title SimpleSwap\\r\\n * @notice An optimized automated market maker (AMM) for token swapping without fees\\r\\n * @dev Implements constant product formula x * y = k without any fees using structs for gas optimization.\\r\\n * This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.\\r\\n * @author Eduardo Moreno - Optimized Version\\r\\n * @custom:security-contact eduardomoreno2503@gmail.com\\r\\n */\\r\\ncontract SimpleSwap {\\r\\n\\r\\n    /// @notice Struct to store all reserve and liquidity data for a trading pair\\r\\n    /// @dev Packs related data together to minimize storage slots and gas costs\\r\\n    struct PairData {\\r\\n        uint256 reserveA;           /// @dev Reserve amount of tokenA in the pair\\r\\n        uint256 reserveB;           /// @dev Reserve amount of tokenB in the pair  \\r\\n        uint256 totalLiquidity;     /// @dev Total liquidity tokens issued for this pair\\r\\n    }\\r\\n\\r\\n    /// @notice Struct to cache storage values during function execution\\r\\n    /// @dev Used to minimize storage reads/writes within functions by loading data once\\r\\n    struct LocalPairData {\\r\\n        uint256 reserveA;           /// @dev Local cache of tokenA reserve\\r\\n        uint256 reserveB;           /// @dev Local cache of tokenB reserve\\r\\n        uint256 totalLiquidity;     /// @dev Local cache of total liquidity\\r\\n        bool isFirstProvision;      /// @dev Flag indicating if this is the first liquidity provision\\r\\n    }\\r\\n\\r\\n    /// @notice Maps a deterministic token pair hash to its PairData\\r\\n    /// @dev Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering\\r\\n    /// to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order\\r\\n    mapping(bytes32 => PairData) public pairs;\\r\\n\\r\\n    /// @notice Stores liquidity token balances for each user in each pair\\r\\n    /// @dev Maps pair hash => user address => liquidity balance\\r\\n    mapping(bytes32 => mapping(address => uint256)) public liquidityBalances;\\r\\n\\r\\n    /// @notice Emitted when tokens are swapped\\r\\n    /// @param tokenIn The address of the token sent into the swap\\r\\n    /// @param tokenOut The address of the token received from the swap\\r\\n    /// @param amountIn The amount of tokenIn that was swapped\\r\\n    /// @param amountOut The amount of tokenOut that was received\\r\\n    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\\r\\n\\r\\n    /// @notice Emitted when liquidity is added or removed from a pair\\r\\n    /// @param tokenA The address of the first token in the pair\\r\\n    /// @param tokenB The address of the second token in the pair\\r\\n    /// @param amountA The amount of tokenA involved in the liquidity action\\r\\n    /// @param amountB The amount of tokenB involved in the liquidity action\\r\\n    /// @param liquidity The amount of liquidity tokens minted (if added) or burned (if removed)\\r\\n    /// @param isAdded True if liquidity was added, false if removed\\r\\n    event LiquidityAction(address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB, uint256 liquidity, bool isAdded);\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to get a deterministic hash for a token pair\\r\\n     * @dev Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing\\r\\n     * to guarantee the same hash for (A, B) and (B, A)\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @return pairHash The keccak256 hash of the ordered token addresses\\r\\n     * @return reversed True if tokenA and tokenB were reversed to maintain order, false otherwise\\r\\n     */\\r\\n    function _getPairHash(address tokenA, address tokenB) public pure returns (bytes32 pairHash, bool reversed) {\\r\\n        if (tokenA < tokenB) {\\r\\n            return (keccak256(abi.encodePacked(tokenA, tokenB)), false);\\r\\n        } else {\\r\\n            return (keccak256(abi.encodePacked(tokenB, tokenA)), true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to load pair data from storage into a LocalPairData struct\\r\\n     * @dev Reads all relevant pair data in a single storage access to minimize gas costs\\r\\n     * Handles token order reversal for consistent data loading\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @return localData A LocalPairData struct containing the reserves, total liquidity, and first provision status\\r\\n     * @return pairHash The deterministic hash of the token pair\\r\\n     * @return reversed True if tokenA and tokenB were reversed during hash calculation\\r\\n     */\\r\\n    function _loadPairData(address tokenA, address tokenB) internal view returns (LocalPairData memory localData, bytes32 pairHash, bool reversed) {\\r\\n        (pairHash, reversed) = _getPairHash(tokenA, tokenB);\\r\\n        PairData storage pairData = pairs[pairHash]; // Single storage read\\r\\n\\r\\n        // Populate localData based on original or reversed order\\r\\n        if (reversed) {\\r\\n            localData = LocalPairData({\\r\\n                reserveA: pairData.reserveB,\\r\\n                reserveB: pairData.reserveA,\\r\\n                totalLiquidity: pairData.totalLiquidity,\\r\\n                isFirstProvision: pairData.totalLiquidity == 0\\r\\n            });\\r\\n        } else {\\r\\n            localData = LocalPairData({\\r\\n                reserveA: pairData.reserveA,\\r\\n                reserveB: pairData.reserveB,\\r\\n                totalLiquidity: pairData.totalLiquidity,\\r\\n                isFirstProvision: pairData.totalLiquidity == 0\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to save updated pair data from a LocalPairData struct to storage\\r\\n     * @dev Updates all relevant pair data in a single storage write to minimize gas costs\\r\\n     * Handles token order reversal to save data consistently\\r\\n     * @param pairHash The deterministic hash of the token pair\\r\\n     * @param reversed True if tokenA and tokenB were reversed during hash calculation\\r\\n     * @param localData A LocalPairData struct containing the updated reserves and total liquidity\\r\\n     */\\r\\n    function _savePairData(bytes32 pairHash, bool reversed, LocalPairData memory localData) internal {\\r\\n        PairData storage pairData = pairs[pairHash]; // Single storage write\\r\\n        \\r\\n        // Save data back to storage, respecting the original order\\r\\n        if (reversed) {\\r\\n            pairData.reserveA = localData.reserveB;\\r\\n            pairData.reserveB = localData.reserveA;\\r\\n        } else {\\r\\n            pairData.reserveA = localData.reserveA;\\r\\n            pairData.reserveB = localData.reserveB;\\r\\n        }\\r\\n        pairData.totalLiquidity = localData.totalLiquidity;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to calculate the amount of liquidity tokens to mint\\r\\n     * @dev For the first liquidity provision, it uses the square root of the product of amounts\\r\\n     * For subsequent provisions, it calculates the proportional liquidity based on existing reserves\\r\\n     * @param amountA The amount of the first token being added\\r\\n     * @param amountB The amount of the second token being added\\r\\n     * @param localData The current LocalPairData containing reserves and total liquidity\\r\\n     * @return The calculated amount of liquidity tokens to mint\\r\\n     */\\r\\n    function _calculateLiquidity(\\r\\n        uint256 amountA,\\r\\n        uint256 amountB,\\r\\n        LocalPairData memory localData\\r\\n    ) internal pure returns (uint256) {\\r\\n        if (localData.isFirstProvision) {\\r\\n            // First liquidity provision: liquidity is sqrt(amountA * amountB)\\r\\n            return _sqrt(amountA * amountB);\\r\\n        }\\r\\n        // Subsequent liquidity provision: calculate proportional liquidity\\r\\n        return _min(\\r\\n            (amountA * localData.totalLiquidity) / localData.reserveA,\\r\\n            (amountB * localData.totalLiquidity) / localData.reserveB\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds liquidity to a token pair pool\\r\\n     * @dev Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract,\\r\\n     * calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event\\r\\n     * Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @param amountADesired Amount of first token to add\\r\\n     * @param amountBDesired Amount of second token to add\\r\\n     * @param amountAMin Minimum amount of first token to add, to prevent front-running\\r\\n     * @param amountBMin Minimum amount of second token to add, to prevent front-running\\r\\n     * @param to Address that will receive the liquidity tokens\\r\\n     * @param deadline Maximum timestamp until which the transaction is valid\\r\\n     * @return amountA The actual amount of first token added\\r\\n     * @return amountB The actual amount of second token added\\r\\n     * @return liquidity The amount of liquidity tokens minted\\r\\n     */\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\\r\\n        require(block.timestamp <= deadline, \\\"expired\\\");\\r\\n        require(amountADesired >= amountAMin && amountBDesired >= amountBMin, \\\"min amt\\\");\\r\\n\\r\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\\r\\n        \\r\\n        liquidity = _calculateLiquidity(amountADesired, amountBDesired, data);\\r\\n\\r\\n        _transferFrom(tokenA, msg.sender, address(this), amountADesired);\\r\\n        _transferFrom(tokenB, msg.sender, address(this), amountBDesired);\\r\\n\\r\\n        // Update reserves and total liquidity in local data\\r\\n        data.reserveA += amountADesired;\\r\\n        data.reserveB += amountBDesired;\\r\\n        data.totalLiquidity += liquidity;\\r\\n\\r\\n        _savePairData(hash, rev, data);\\r\\n        liquidityBalances[hash][to] += liquidity;\\r\\n\\r\\n        emit LiquidityAction(tokenA, tokenB, amountADesired, amountBDesired, liquidity, true);\\r\\n        return (amountADesired, amountBDesired, liquidity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes liquidity from a token pair pool\\r\\n     * @dev Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB`\\r\\n     * back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event\\r\\n     * Requires the received amounts to be at least `amountAMin` and `amountBMin`\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @param liquidity Amount of liquidity tokens to burn\\r\\n     * @param amountAMin Minimum amount of first token to receive, to prevent front-running\\r\\n     * @param amountBMin Minimum amount of second token to receive, to prevent front-running\\r\\n     * @param to Address that will receive the tokens\\r\\n     * @param deadline Maximum timestamp until which the transaction is valid\\r\\n     * @return amountA The actual amount of first token returned\\r\\n     * @return amountB The actual amount of second token returned\\r\\n     */\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB) {\\r\\n        require(block.timestamp <= deadline, \\\"expired\\\");\\r\\n        \\r\\n        // Load data once to check liquidity balance before further calculations\\r\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\\r\\n        require(liquidityBalances[hash][msg.sender] >= liquidity, \\\"insuf liq\\\");\\r\\n\\r\\n        amountA = (liquidity * data.reserveA) / data.totalLiquidity;\\r\\n        amountB = (liquidity * data.reserveB) / data.totalLiquidity;\\r\\n        require(amountA >= amountAMin && amountB >= amountBMin, \\\"min amt\\\");\\r\\n\\r\\n        // Update reserves and total liquidity in local data\\r\\n        data.reserveA -= amountA;\\r\\n        data.reserveB -= amountB;\\r\\n        data.totalLiquidity -= liquidity;\\r\\n\\r\\n        _savePairData(hash, rev, data);\\r\\n        liquidityBalances[hash][msg.sender] -= liquidity;\\r\\n\\r\\n        _transfer(tokenA, to, amountA);\\r\\n        _transfer(tokenB, to, amountB);\\r\\n\\r\\n        emit LiquidityAction(tokenA, tokenB, amountA, amountB, liquidity, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Swaps an exact amount of input tokens for output tokens\\r\\n     * @dev Transfers `amountIn` of `path[0]` from `msg.sender` to the contract,\\r\\n     * calculates the output amount of `path[1]`, transfers `amountOut` to `to` address,\\r\\n     * updates reserves, and emits a `Swap` event\\r\\n     * Requires `amountOut` to be at least `amountOutMin`\\r\\n     * @param amountIn Amount of input tokens to swap\\r\\n     * @param amountOutMin Minimum amount of output tokens to receive, to prevent front-running\\r\\n     * @param path Array containing [tokenIn, tokenOut] addresses\\r\\n     * @param to Address that will receive the output tokens\\r\\n     * @param deadline Maximum timestamp until which the transaction is valid\\r\\n     */\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external {\\r\\n        require(block.timestamp <= deadline, \\\"expired\\\");\\r\\n        require(path.length == 2, \\\"bad path\\\");\\r\\n\\r\\n        // Load data once\\r\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(path[0], path[1]);\\r\\n        \\r\\n        // Load pair data and calculate output without any fees\\r\\n\\r\\n\\r\\n\\r\\n        // No fees applied - using direct amountIn for AMM calculation\\r\\n\\r\\n        uint256 amountOut = getAmountOut(amountIn, data.reserveA, data.reserveB);\\r\\n        require(amountOut >= amountOutMin, \\\"min out\\\");\\r\\n\\r\\n        _transferFrom(path[0], msg.sender, address(this), amountIn);\\r\\n\\r\\n        // Update reserves in local data\\r\\n        data.reserveA += amountIn; // Add input amount to reserves\\r\\n        data.reserveB -= amountOut;\\r\\n\\r\\n        _savePairData(hash, rev, data);\\r\\n        _transfer(path[1], to, amountOut);\\r\\n\\r\\n        emit Swap(path[0], path[1], amountIn, amountOut);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current price of tokenA in terms of tokenB\\r\\n     * @dev Calculates the price based on the current reserves of the pair\\r\\n     * The price is returned as a fixed-point number with 18 decimal places (wei equivalent)\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @return price Price of tokenA in terms of tokenB, scaled by 1e18\\r\\n     */\\r\\n    function getPrice(address tokenA, address tokenB) external view returns (uint256 price) {\\r\\n        (LocalPairData memory data,,) = _loadPairData(tokenA, tokenB);\\r\\n        // Ensure reserves are not zero to prevent division by zero\\r\\n        require(data.reserveA > 0, \\\"zero reserve\\\");\\r\\n        return (data.reserveB * 1e18) / data.reserveA;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current reserve amounts for a token pair\\r\\n     * @dev Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair\\r\\n     * @param tokenA Address of the first token\\r\\n     * @param tokenB Address of the second token\\r\\n     * @return reserveA The current reserve amount of the first token\\r\\n     * @return reserveB The current reserve amount of the second token\\r\\n     */\\r\\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB) {\\r\\n        (LocalPairData memory data,,) = _loadPairData(tokenA, tokenB);\\r\\n        return (data.reserveA, data.reserveB);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the output amount for a swap given an input amount and current reserves\\r\\n     * @dev Implements the constant product formula (x * y = k) to determine the amount of output tokens\\r\\n     * received for a given amount of input tokens\\r\\n     * @param amountIn Amount of input tokens\\r\\n     * @param reserveIn Reserve of the input token\\r\\n     * @param reserveOut Reserve of the output token\\r\\n     * @return amountOut Amount of output tokens to receive\\r\\n     */\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) public pure returns (uint256) {\\r\\n        require(amountIn > 0, \\\"bad amt\\\");\\r\\n        require(reserveIn > 0, \\\"bad amt\\\");\\r\\n        require(reserveOut > 0, \\\"bad amt\\\");\\r\\n        return (amountIn * reserveOut) / (reserveIn + amountIn);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to handle `transferFrom` operations for ERC-20 tokens\\r\\n     * Assumes the `token` address is a valid ERC-20 contract\\r\\n     * @param token The address of the ERC-20 token contract\\r\\n     * @param from The address from which tokens are transferred\\r\\n     * @param to The address to which tokens are transferred\\r\\n     * @param amount The amount of tokens to transfer\\r\\n     */\\r\\n    function _transferFrom(address token, address from, address to, uint256 amount) internal {\\r\\n        (bool success,) = token.call(\\r\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", from, to, amount)\\r\\n        );\\r\\n        require(success, \\\"tf fail\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to handle `transfer` operations for ERC-20 tokens\\r\\n     * Assumes the `token` address is a valid ERC-20 contract\\r\\n     * @param token The address of the ERC-20 token contract\\r\\n     * @param to The address to which tokens are transferred\\r\\n     * @param amount The amount of tokens to transfer\\r\\n     */\\r\\n    function _transfer(address token, address to, uint256 amount) internal {\\r\\n        (bool success,) = token.call(\\r\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", to, amount)\\r\\n        );\\r\\n        require(success, \\\"t fail\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to calculate the integer square root of a number\\r\\n     * Used for initial liquidity calculation\\r\\n     * @param y The number for which to calculate the square root\\r\\n     * @return z The integer square root of y\\r\\n     */\\r\\n    function _sqrt(uint256 y) internal pure returns (uint256 z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint256 x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to return the minimum of two unsigned integers\\r\\n     * @param x The first number\\r\\n     * @param y The second number\\r\\n     * @return The smaller of x and y\\r\\n     */\\r\\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        return x < y ? x : y;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe804905508c3cfa89533f99b18110cf37d947800ad3426747348565c1f593e50\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506110f6806100206000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063ac41865a11610066578063ac41865a14610148578063baa2abde1461015b578063d52bb6f414610183578063e8e3370014610196578063e9fe6f2b146101a957600080fd5b8063054d50d41461009857806338ed1739146100be5780634fb5bf7f146100d3578063673e0481146100fe575b600080fd5b6100ab6100a6366004610d77565b6101d1565b6040519081526020015b60405180910390f35b6100d16100cc366004610dba565b610263565b005b6100ab6100e1366004610e5c565b600160209081526000928352604080842090915290825290205481565b61012d61010c366004610e88565b60006020819052908152604090208054600182015460029092015490919083565b604080519384526020840192909252908201526060016100b5565b6100ab610156366004610ea1565b6104be565b61016e610169366004610ecb565b61053a565b604080519283526020830191909152016100b5565b61016e610191366004610ea1565b610747565b61012d6101a4366004610f35565b61076e565b6101bc6101b7366004610ea1565b610919565b604080519283529015156020830152016100b5565b60008084116101fb5760405162461bcd60e51b81526004016101f290610fa9565b60405180910390fd5b6000831161021b5760405162461bcd60e51b81526004016101f290610fa9565b6000821161023b5760405162461bcd60e51b81526004016101f290610fa9565b6102458484610fe0565b61024f8386610ff3565b610259919061100a565b90505b9392505050565b804211156102835760405162461bcd60e51b81526004016101f29061102c565b600283146102be5760405162461bcd60e51b81526020600482015260086024820152670c4c2c840e0c2e8d60c31b60448201526064016101f2565b600080600061031b878760008181106102d9576102d961104d565b90506020020160208101906102ee9190611063565b888860018181106103015761030161104d565b90506020020160208101906103169190611063565b6109ca565b92509250925060006103368a856000015186602001516101d1565b9050888110156103725760405162461bcd60e51b81526020600482015260076024820152661b5a5b881bdd5d60ca1b60448201526064016101f2565b6103a5888860008181106103885761038861104d565b905060200201602081019061039d9190611063565b33308d610a83565b89846000018181516103b79190610fe0565b9052506020840180518291906103ce90839061107e565b9052506103dc838386610b68565b61040e888860018181106103f2576103f261104d565b90506020020160208101906104079190611063565b8783610bae565b878760018181106104215761042161104d565b90506020020160208101906104369190611063565b6001600160a01b0316888860008181106104525761045261104d565b90506020020160208101906104679190611063565b6001600160a01b03167ffa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe2358c846040516104aa929190918252602082015260400190565b60405180910390a350505050505050505050565b6000806104cb84846109ca565b5050805190915061050d5760405162461bcd60e51b815260206004820152600c60248201526b7a65726f207265736572766560a01b60448201526064016101f2565b8051602082015161052690670de0b6b3a7640000610ff3565b610530919061100a565b9150505b92915050565b6000808242111561055d5760405162461bcd60e51b81526004016101f29061102c565b600080600061056c8c8c6109ca565b600082815260016020908152604080832033845290915290205492955090935091508a11156105c95760405162461bcd60e51b8152602060048201526009602482015268696e737566206c697160b81b60448201526064016101f2565b604083015183516105da908c610ff3565b6105e4919061100a565b9450826040015183602001518b6105fb9190610ff3565b610605919061100a565b93508885101580156106175750878410155b61064d5760405162461bcd60e51b81526020600482015260076024820152661b5a5b88185b5d60ca1b60448201526064016101f2565b848360000181815161065f919061107e565b90525060208301805185919061067690839061107e565b9052506040830180518b919061068d90839061107e565b90525061069b828285610b68565b6000828152600160209081526040808320338452909152812080548c92906106c490849061107e565b909155506106d590508c8887610bae565b6106e08b8886610bae565b60408051868152602081018690529081018b9052600060608201526001600160a01b03808d1691908e16907fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a9060800160405180910390a350505097509795505050505050565b600080600061075685856109ca565b505080516020909101519093509150505b9250929050565b6000806000834211156107935760405162461bcd60e51b81526004016101f29061102c565b8689101580156107a35750858810155b6107d95760405162461bcd60e51b81526020600482015260076024820152661b5a5b88185b5d60ca1b60448201526064016101f2565b60008060006107e88e8e6109ca565b9250925092506107f98c8c85610c89565b93506108078e33308f610a83565b6108138d33308e610a83565b8b836000018181516108259190610fe0565b9052506020830180518c919061083c908390610fe0565b905250604083018051859190610853908390610fe0565b905250610861828285610b68565b60008281526001602090815260408083206001600160a01b038c16845290915281208054869290610893908490610fe0565b925050819055508c6001600160a01b03168e6001600160a01b03167fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a8e8e8860016040516108fc9493929190938452602084019290925260408301521515606082015260800190565b60405180910390a350999c989b5090995096975050505050505050565b600080826001600160a01b0316846001600160a01b03161015610980576040516bffffffffffffffffffffffff19606086811b8216602084015285901b16603482015260480160405160208183030381529060405280519060200120600091509150610767565b6040516bffffffffffffffffffffffff19606085811b8216602084015286901b16603482015260480160405160208183030381529060405280519060200120600191509150610767565b6109f760405180608001604052806000815260200160008152602001600081526020016000151581525090565b600080610a048585610919565b600082815260208190526040902091935091508115610a4e576040805160808101825260018301548152825460208201526002830154918101829052901560608201529350610a7b565b60408051608081018252825481526001830154602082015260028301549181018290529015606082015293505b509250925092565b6040516001600160a01b0384811660248301528381166044830152606482018390526000919086169060840160408051601f198184030181529181526020820180516001600160e01b03166323b872dd60e01b17905251610ae49190611091565b6000604051808303816000865af19150503d8060008114610b21576040519150601f19603f3d011682016040523d82523d6000602084013e610b26565b606091505b5050905080610b615760405162461bcd60e51b81526020600482015260076024820152661d198819985a5b60ca1b60448201526064016101f2565b5050505050565b60008381526020819052604090208215610b8f576020820151815581516001820155610b9e565b81518155602082015160018201555b6040909101516002909101555050565b6040516001600160a01b038381166024830152604482018390526000919085169060640160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b17905251610c079190611091565b6000604051808303816000865af19150503d8060008114610c44576040519150601f19603f3d011682016040523d82523d6000602084013e610c49565b606091505b5050905080610c835760405162461bcd60e51b81526020600482015260066024820152651d0819985a5b60d21b60448201526064016101f2565b50505050565b6000816060015115610cae57610ca7610ca28486610ff3565b610cf1565b905061025c565b815160408301516102599190610cc49087610ff3565b610cce919061100a565b60208401516040850151610ce29087610ff3565b610cec919061100a565b610d61565b60006003821115610d525750806000610d0b60028361100a565b610d16906001610fe0565b90505b81811015610d4c57905080600281610d31818661100a565b610d3b9190610fe0565b610d45919061100a565b9050610d19565b50919050565b8115610d5c575060015b919050565b6000818310610d70578161025c565b5090919050565b600080600060608486031215610d8c57600080fd5b505081359360208301359350604090920135919050565b80356001600160a01b0381168114610d5c57600080fd5b60008060008060008060a08789031215610dd357600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115610df957600080fd5b818901915089601f830112610e0d57600080fd5b813581811115610e1c57600080fd5b8a60208260051b8501011115610e3157600080fd5b602083019650809550505050610e4960608801610da3565b9150608087013590509295509295509295565b60008060408385031215610e6f57600080fd5b82359150610e7f60208401610da3565b90509250929050565b600060208284031215610e9a57600080fd5b5035919050565b60008060408385031215610eb457600080fd5b610ebd83610da3565b9150610e7f60208401610da3565b600080600080600080600060e0888a031215610ee657600080fd5b610eef88610da3565b9650610efd60208901610da3565b9550604088013594506060880135935060808801359250610f2060a08901610da3565b915060c0880135905092959891949750929550565b600080600080600080600080610100898b031215610f5257600080fd5b610f5b89610da3565b9750610f6960208a01610da3565b965060408901359550606089013594506080890135935060a08901359250610f9360c08a01610da3565b915060e089013590509295985092959890939650565b60208082526007908201526618985908185b5d60ca1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561053457610534610fca565b808202811582820484141761053457610534610fca565b60008261102757634e487b7160e01b600052601260045260246000fd5b500490565b602080825260079082015266195e1c1a5c995960ca1b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561107557600080fd5b61025c82610da3565b8181038181111561053457610534610fca565b6000825160005b818110156110b25760208186018101518583015201611098565b50600092019182525091905056fea2646970667358221220f80afbdfe6fbcc714ae1f0aa012c532b5e60dbb9e9484a8c38143521ea8d99aa64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063ac41865a11610066578063ac41865a14610148578063baa2abde1461015b578063d52bb6f414610183578063e8e3370014610196578063e9fe6f2b146101a957600080fd5b8063054d50d41461009857806338ed1739146100be5780634fb5bf7f146100d3578063673e0481146100fe575b600080fd5b6100ab6100a6366004610d77565b6101d1565b6040519081526020015b60405180910390f35b6100d16100cc366004610dba565b610263565b005b6100ab6100e1366004610e5c565b600160209081526000928352604080842090915290825290205481565b61012d61010c366004610e88565b60006020819052908152604090208054600182015460029092015490919083565b604080519384526020840192909252908201526060016100b5565b6100ab610156366004610ea1565b6104be565b61016e610169366004610ecb565b61053a565b604080519283526020830191909152016100b5565b61016e610191366004610ea1565b610747565b61012d6101a4366004610f35565b61076e565b6101bc6101b7366004610ea1565b610919565b604080519283529015156020830152016100b5565b60008084116101fb5760405162461bcd60e51b81526004016101f290610fa9565b60405180910390fd5b6000831161021b5760405162461bcd60e51b81526004016101f290610fa9565b6000821161023b5760405162461bcd60e51b81526004016101f290610fa9565b6102458484610fe0565b61024f8386610ff3565b610259919061100a565b90505b9392505050565b804211156102835760405162461bcd60e51b81526004016101f29061102c565b600283146102be5760405162461bcd60e51b81526020600482015260086024820152670c4c2c840e0c2e8d60c31b60448201526064016101f2565b600080600061031b878760008181106102d9576102d961104d565b90506020020160208101906102ee9190611063565b888860018181106103015761030161104d565b90506020020160208101906103169190611063565b6109ca565b92509250925060006103368a856000015186602001516101d1565b9050888110156103725760405162461bcd60e51b81526020600482015260076024820152661b5a5b881bdd5d60ca1b60448201526064016101f2565b6103a5888860008181106103885761038861104d565b905060200201602081019061039d9190611063565b33308d610a83565b89846000018181516103b79190610fe0565b9052506020840180518291906103ce90839061107e565b9052506103dc838386610b68565b61040e888860018181106103f2576103f261104d565b90506020020160208101906104079190611063565b8783610bae565b878760018181106104215761042161104d565b90506020020160208101906104369190611063565b6001600160a01b0316888860008181106104525761045261104d565b90506020020160208101906104679190611063565b6001600160a01b03167ffa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe2358c846040516104aa929190918252602082015260400190565b60405180910390a350505050505050505050565b6000806104cb84846109ca565b5050805190915061050d5760405162461bcd60e51b815260206004820152600c60248201526b7a65726f207265736572766560a01b60448201526064016101f2565b8051602082015161052690670de0b6b3a7640000610ff3565b610530919061100a565b9150505b92915050565b6000808242111561055d5760405162461bcd60e51b81526004016101f29061102c565b600080600061056c8c8c6109ca565b600082815260016020908152604080832033845290915290205492955090935091508a11156105c95760405162461bcd60e51b8152602060048201526009602482015268696e737566206c697160b81b60448201526064016101f2565b604083015183516105da908c610ff3565b6105e4919061100a565b9450826040015183602001518b6105fb9190610ff3565b610605919061100a565b93508885101580156106175750878410155b61064d5760405162461bcd60e51b81526020600482015260076024820152661b5a5b88185b5d60ca1b60448201526064016101f2565b848360000181815161065f919061107e565b90525060208301805185919061067690839061107e565b9052506040830180518b919061068d90839061107e565b90525061069b828285610b68565b6000828152600160209081526040808320338452909152812080548c92906106c490849061107e565b909155506106d590508c8887610bae565b6106e08b8886610bae565b60408051868152602081018690529081018b9052600060608201526001600160a01b03808d1691908e16907fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a9060800160405180910390a350505097509795505050505050565b600080600061075685856109ca565b505080516020909101519093509150505b9250929050565b6000806000834211156107935760405162461bcd60e51b81526004016101f29061102c565b8689101580156107a35750858810155b6107d95760405162461bcd60e51b81526020600482015260076024820152661b5a5b88185b5d60ca1b60448201526064016101f2565b60008060006107e88e8e6109ca565b9250925092506107f98c8c85610c89565b93506108078e33308f610a83565b6108138d33308e610a83565b8b836000018181516108259190610fe0565b9052506020830180518c919061083c908390610fe0565b905250604083018051859190610853908390610fe0565b905250610861828285610b68565b60008281526001602090815260408083206001600160a01b038c16845290915281208054869290610893908490610fe0565b925050819055508c6001600160a01b03168e6001600160a01b03167fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a8e8e8860016040516108fc9493929190938452602084019290925260408301521515606082015260800190565b60405180910390a350999c989b5090995096975050505050505050565b600080826001600160a01b0316846001600160a01b03161015610980576040516bffffffffffffffffffffffff19606086811b8216602084015285901b16603482015260480160405160208183030381529060405280519060200120600091509150610767565b6040516bffffffffffffffffffffffff19606085811b8216602084015286901b16603482015260480160405160208183030381529060405280519060200120600191509150610767565b6109f760405180608001604052806000815260200160008152602001600081526020016000151581525090565b600080610a048585610919565b600082815260208190526040902091935091508115610a4e576040805160808101825260018301548152825460208201526002830154918101829052901560608201529350610a7b565b60408051608081018252825481526001830154602082015260028301549181018290529015606082015293505b509250925092565b6040516001600160a01b0384811660248301528381166044830152606482018390526000919086169060840160408051601f198184030181529181526020820180516001600160e01b03166323b872dd60e01b17905251610ae49190611091565b6000604051808303816000865af19150503d8060008114610b21576040519150601f19603f3d011682016040523d82523d6000602084013e610b26565b606091505b5050905080610b615760405162461bcd60e51b81526020600482015260076024820152661d198819985a5b60ca1b60448201526064016101f2565b5050505050565b60008381526020819052604090208215610b8f576020820151815581516001820155610b9e565b81518155602082015160018201555b6040909101516002909101555050565b6040516001600160a01b038381166024830152604482018390526000919085169060640160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b17905251610c079190611091565b6000604051808303816000865af19150503d8060008114610c44576040519150601f19603f3d011682016040523d82523d6000602084013e610c49565b606091505b5050905080610c835760405162461bcd60e51b81526020600482015260066024820152651d0819985a5b60d21b60448201526064016101f2565b50505050565b6000816060015115610cae57610ca7610ca28486610ff3565b610cf1565b905061025c565b815160408301516102599190610cc49087610ff3565b610cce919061100a565b60208401516040850151610ce29087610ff3565b610cec919061100a565b610d61565b60006003821115610d525750806000610d0b60028361100a565b610d16906001610fe0565b90505b81811015610d4c57905080600281610d31818661100a565b610d3b9190610fe0565b610d45919061100a565b9050610d19565b50919050565b8115610d5c575060015b919050565b6000818310610d70578161025c565b5090919050565b600080600060608486031215610d8c57600080fd5b505081359360208301359350604090920135919050565b80356001600160a01b0381168114610d5c57600080fd5b60008060008060008060a08789031215610dd357600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115610df957600080fd5b818901915089601f830112610e0d57600080fd5b813581811115610e1c57600080fd5b8a60208260051b8501011115610e3157600080fd5b602083019650809550505050610e4960608801610da3565b9150608087013590509295509295509295565b60008060408385031215610e6f57600080fd5b82359150610e7f60208401610da3565b90509250929050565b600060208284031215610e9a57600080fd5b5035919050565b60008060408385031215610eb457600080fd5b610ebd83610da3565b9150610e7f60208401610da3565b600080600080600080600060e0888a031215610ee657600080fd5b610eef88610da3565b9650610efd60208901610da3565b9550604088013594506060880135935060808801359250610f2060a08901610da3565b915060c0880135905092959891949750929550565b600080600080600080600080610100898b031215610f5257600080fd5b610f5b89610da3565b9750610f6960208a01610da3565b965060408901359550606089013594506080890135935060a08901359250610f9360c08a01610da3565b915060e089013590509295985092959890939650565b60208082526007908201526618985908185b5d60ca1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561053457610534610fca565b808202811582820484141761053457610534610fca565b60008261102757634e487b7160e01b600052601260045260246000fd5b500490565b602080825260079082015266195e1c1a5c995960ca1b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561107557600080fd5b61025c82610da3565b8181038181111561053457610534610fca565b6000825160005b818110156110b25760208186018101518583015201611098565b50600092019182525091905056fea2646970667358221220f80afbdfe6fbcc714ae1f0aa012c532b5e60dbb9e9484a8c38143521ea8d99aa64736f6c63430008140033",
  "devdoc": {
    "author": "Eduardo Moreno - Optimized Version",
    "custom:security-contact": "eduardomoreno2503@gmail.com",
    "details": "Implements constant product formula x * y = k without any fees using structs for gas optimization. This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.",
    "events": {
      "LiquidityAction(address,address,uint256,uint256,uint256,bool)": {
        "params": {
          "amountA": "The amount of tokenA involved in the liquidity action",
          "amountB": "The amount of tokenB involved in the liquidity action",
          "isAdded": "True if liquidity was added, false if removed",
          "liquidity": "The amount of liquidity tokens minted (if added) or burned (if removed)",
          "tokenA": "The address of the first token in the pair",
          "tokenB": "The address of the second token in the pair"
        }
      },
      "Swap(address,address,uint256,uint256)": {
        "params": {
          "amountIn": "The amount of tokenIn that was swapped",
          "amountOut": "The amount of tokenOut that was received",
          "tokenIn": "The address of the token sent into the swap",
          "tokenOut": "The address of the token received from the swap"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "_getPairHash(address,address)": {
        "details": "Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing to guarantee the same hash for (A, B) and (B, A)",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "pairHash": "The keccak256 hash of the ordered token addresses",
          "reversed": "True if tokenA and tokenB were reversed to maintain order, false otherwise"
        }
      },
      "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
        "details": "Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract, calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively",
        "params": {
          "amountADesired": "Amount of first token to add",
          "amountAMin": "Minimum amount of first token to add, to prevent front-running",
          "amountBDesired": "Amount of second token to add",
          "amountBMin": "Minimum amount of second token to add, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "to": "Address that will receive the liquidity tokens",
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "amountA": "The actual amount of first token added",
          "amountB": "The actual amount of second token added",
          "liquidity": "The amount of liquidity tokens minted"
        }
      },
      "getAmountOut(uint256,uint256,uint256)": {
        "details": "Implements the constant product formula (x * y = k) to determine the amount of output tokens received for a given amount of input tokens",
        "params": {
          "amountIn": "Amount of input tokens",
          "reserveIn": "Reserve of the input token",
          "reserveOut": "Reserve of the output token"
        },
        "returns": {
          "_0": "amountOut Amount of output tokens to receive"
        }
      },
      "getPrice(address,address)": {
        "details": "Calculates the price based on the current reserves of the pair The price is returned as a fixed-point number with 18 decimal places (wei equivalent)",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "price": "Price of tokenA in terms of tokenB, scaled by 1e18"
        }
      },
      "getReserves(address,address)": {
        "details": "Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "reserveA": "The current reserve amount of the first token",
          "reserveB": "The current reserve amount of the second token"
        }
      },
      "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
        "details": "Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB` back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event Requires the received amounts to be at least `amountAMin` and `amountBMin`",
        "params": {
          "amountAMin": "Minimum amount of first token to receive, to prevent front-running",
          "amountBMin": "Minimum amount of second token to receive, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "liquidity": "Amount of liquidity tokens to burn",
          "to": "Address that will receive the tokens",
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "amountA": "The actual amount of first token returned",
          "amountB": "The actual amount of second token returned"
        }
      },
      "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
        "details": "Transfers `amountIn` of `path[0]` from `msg.sender` to the contract, calculates the output amount of `path[1]`, transfers `amountOut` to `to` address, updates reserves, and emits a `Swap` event Requires `amountOut` to be at least `amountOutMin`",
        "params": {
          "amountIn": "Amount of input tokens to swap",
          "amountOutMin": "Minimum amount of output tokens to receive, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "path": "Array containing [tokenIn, tokenOut] addresses",
          "to": "Address that will receive the output tokens"
        }
      }
    },
    "stateVariables": {
      "liquidityBalances": {
        "details": "Maps pair hash => user address => liquidity balance"
      },
      "pairs": {
        "details": "Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order"
      }
    },
    "title": "SimpleSwap",
    "version": 1
  },
  "userdoc": {
    "events": {
      "LiquidityAction(address,address,uint256,uint256,uint256,bool)": {
        "notice": "Emitted when liquidity is added or removed from a pair"
      },
      "Swap(address,address,uint256,uint256)": {
        "notice": "Emitted when tokens are swapped"
      }
    },
    "kind": "user",
    "methods": {
      "_getPairHash(address,address)": {
        "notice": "Internal function to get a deterministic hash for a token pair"
      },
      "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
        "notice": "Adds liquidity to a token pair pool"
      },
      "getAmountOut(uint256,uint256,uint256)": {
        "notice": "Calculates the output amount for a swap given an input amount and current reserves"
      },
      "getPrice(address,address)": {
        "notice": "Gets the current price of tokenA in terms of tokenB"
      },
      "getReserves(address,address)": {
        "notice": "Gets the current reserve amounts for a token pair"
      },
      "liquidityBalances(bytes32,address)": {
        "notice": "Stores liquidity token balances for each user in each pair"
      },
      "pairs(bytes32)": {
        "notice": "Maps a deterministic token pair hash to its PairData"
      },
      "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
        "notice": "Removes liquidity from a token pair pool"
      },
      "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
        "notice": "Swaps an exact amount of input tokens for output tokens"
      }
    },
    "notice": "An optimized automated market maker (AMM) for token swapping without fees",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 31,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "pairs",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_struct(PairData)12_storage)"
      },
      {
        "astId": 38,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "liquidityBalances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_bytes32,t_struct(PairData)12_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct SimpleSwap.PairData)",
        "numberOfBytes": "32",
        "value": "t_struct(PairData)12_storage"
      },
      "t_struct(PairData)12_storage": {
        "encoding": "inplace",
        "label": "struct SimpleSwap.PairData",
        "members": [
          {
            "astId": 5,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "reserveA",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 8,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "reserveB",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "totalLiquidity",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}