{
  "address": "0x5F1C2c20248BA5A444256c21592125EaF08b23A1",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isAdded",
          "type": "bool"
        }
      ],
      "name": "LiquidityAction",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "Swap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "_getPairHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "pairHash",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "reversed",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountADesired",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBDesired",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountAMin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBMin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "addLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "slippageBps",
          "type": "uint256"
        }
      ],
      "name": "calculateMinOutputWithSlippage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        }
      ],
      "name": "estimateSwapGas",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "gasEstimate",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveOut",
          "type": "uint256"
        }
      ],
      "name": "getAmountOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getReserves",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveB",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "liquidityBalances",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "pairs",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveB",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalLiquidity",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountAMin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBMin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "removeLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "swapExactTokensForTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x62697cf8750ae4a670ce8131e6c5da8d2a91f76c92e9e23ff54462359f4f9987",
  "receipt": {
    "to": null,
    "from": "0x4829f4f3aadee47Cb1cc795B2eC78A166042e918",
    "contractAddress": "0x5F1C2c20248BA5A444256c21592125EaF08b23A1",
    "transactionIndex": 80,
    "gasUsed": "1318268",
    "logsBloom": "0x00000000000000000080001000000040000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000100000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x063db241145219bb4272d45f1fed6e3fbf7a1f43ff712fdafedf59663f6fc56b",
    "transactionHash": "0x62697cf8750ae4a670ce8131e6c5da8d2a91f76c92e9e23ff54462359f4f9987",
    "logs": [
      {
        "transactionIndex": 80,
        "blockNumber": 8779146,
        "transactionHash": "0x62697cf8750ae4a670ce8131e6c5da8d2a91f76c92e9e23ff54462359f4f9987",
        "address": "0x5F1C2c20248BA5A444256c21592125EaF08b23A1",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000004829f4f3aadee47cb1cc795b2ec78a166042e918"
        ],
        "data": "0x",
        "logIndex": 144,
        "blockHash": "0x063db241145219bb4272d45f1fed6e3fbf7a1f43ff712fdafedf59663f6fc56b"
      }
    ],
    "blockNumber": 8779146,
    "cumulativeGasUsed": "9231870",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "99cf0e2285364f0de902e5320f9f3048",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdded\",\"type\":\"bool\"}],\"name\":\"LiquidityAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"_getPairHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"reversed\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"slippageBps\",\"type\":\"uint256\"}],\"name\":\"calculateMinOutputWithSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"estimateSwapGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLiquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Eduardo Moreno - Optimized Version\",\"custom:security-contact\":\"eduardomoreno2503@gmail.com\",\"details\":\"Implements constant product formula x * y = k without any fees using structs for gas optimization. This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.\",\"events\":{\"LiquidityAction(address,address,uint256,uint256,uint256,bool)\":{\"params\":{\"amountA\":\"The amount of tokenA involved in the liquidity action\",\"amountB\":\"The amount of tokenB involved in the liquidity action\",\"isAdded\":\"True if liquidity was added, false if removed\",\"liquidity\":\"The amount of liquidity tokens minted (if added) or burned (if removed)\",\"tokenA\":\"The address of the first token in the pair\",\"tokenB\":\"The address of the second token in the pair\"}},\"OwnershipTransferred(address,address)\":{\"params\":{\"newOwner\":\"The address of the new owner\",\"previousOwner\":\"The address of the previous owner\"}},\"Paused(address)\":{\"params\":{\"account\":\"The address that triggered the pause\"}},\"Swap(address,address,uint256,uint256)\":{\"params\":{\"amountIn\":\"The amount of tokenIn that was swapped\",\"amountOut\":\"The amount of tokenOut that was received\",\"tokenIn\":\"The address of the token sent into the swap\",\"tokenOut\":\"The address of the token received from the swap\"}},\"Unpaused(address)\":{\"params\":{\"account\":\"The address that triggered the unpause\"}}},\"kind\":\"dev\",\"methods\":{\"_getPairHash(address,address)\":{\"details\":\"Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing to guarantee the same hash for (A, B) and (B, A)\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"pairHash\":\"The keccak256 hash of the ordered token addresses\",\"reversed\":\"True if tokenA and tokenB were reversed to maintain order, false otherwise\"}},\"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)\":{\"details\":\"Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract, calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively\",\"params\":{\"amountADesired\":\"Amount of first token to add\",\"amountAMin\":\"Minimum amount of first token to add, to prevent front-running\",\"amountBDesired\":\"Amount of second token to add\",\"amountBMin\":\"Minimum amount of second token to add, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"to\":\"Address that will receive the liquidity tokens\",\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"amountA\":\"The actual amount of first token added\",\"amountB\":\"The actual amount of second token added\",\"liquidity\":\"The amount of liquidity tokens minted\"}},\"calculateMinOutputWithSlippage(uint256,address[],uint256)\":{\"details\":\"Calculates minimum output with slippage tolerance in basis points\",\"params\":{\"amountIn\":\"Amount of input tokens\",\"path\":\"Array containing [tokenIn, tokenOut] addresses  \",\"slippageBps\":\"Slippage tolerance in basis points (100 = 1%)\"},\"returns\":{\"amountOutMin\":\"Minimum output amount considering slippage\"}},\"estimateSwapGas(uint256,address[])\":{\"details\":\"Provides gas estimation without executing the actual swap\",\"params\":{\"amountIn\":\"Amount of input tokens to swap\",\"path\":\"Array containing [tokenIn, tokenOut] addresses\"},\"returns\":{\"gasEstimate\":\"Estimated gas cost for the swap operation\"}},\"getAmountOut(uint256,uint256,uint256)\":{\"details\":\"Implements the constant product formula (x * y = k) to determine the amount of output tokens received for a given amount of input tokens\",\"params\":{\"amountIn\":\"Amount of input tokens\",\"reserveIn\":\"Reserve of the input token\",\"reserveOut\":\"Reserve of the output token\"},\"returns\":{\"_0\":\"amountOut Amount of output tokens to receive\"}},\"getPrice(address,address)\":{\"details\":\"Calculates the price based on the current reserves of the pair The price is returned as a fixed-point number with 18 decimal places (wei equivalent)\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"price\":\"Price of tokenA in terms of tokenB, scaled by 1e18\"}},\"getReserves(address,address)\":{\"details\":\"Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair\",\"params\":{\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"reserveA\":\"The current reserve amount of the first token\",\"reserveB\":\"The current reserve amount of the second token\"}},\"pause()\":{\"details\":\"Only the owner can call this function during emergency situations\"},\"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)\":{\"details\":\"Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB` back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event Requires the received amounts to be at least `amountAMin` and `amountBMin`\",\"params\":{\"amountAMin\":\"Minimum amount of first token to receive, to prevent front-running\",\"amountBMin\":\"Minimum amount of second token to receive, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"liquidity\":\"Amount of liquidity tokens to burn\",\"to\":\"Address that will receive the tokens\",\"tokenA\":\"Address of the first token\",\"tokenB\":\"Address of the second token\"},\"returns\":{\"amountA\":\"The actual amount of first token returned\",\"amountB\":\"The actual amount of second token returned\"}},\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\":{\"details\":\"Transfers `amountIn` of `path[0]` from `msg.sender` to the contract, calculates the output amount of `path[1]`, transfers `amountOut` to `to` address, updates reserves, and emits a `Swap` event Requires `amountOut` to be at least `amountOutMin`\",\"params\":{\"amountIn\":\"Amount of input tokens to swap\",\"amountOutMin\":\"Minimum amount of output tokens to receive, to prevent front-running\",\"deadline\":\"Maximum timestamp until which the transaction is valid\",\"path\":\"Array containing [tokenIn, tokenOut] addresses\",\"to\":\"Address that will receive the output tokens\"}},\"transferOwnership(address)\":{\"details\":\"Only the current owner can call this function\",\"params\":{\"newOwner\":\"The address of the new owner\"}},\"unpause()\":{\"details\":\"Only the owner can call this function to resume operations\"}},\"stateVariables\":{\"liquidityBalances\":{\"details\":\"Maps pair hash => user address => liquidity balance\"},\"pairs\":{\"details\":\"Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order\"}},\"title\":\"SimpleSwap\",\"version\":1},\"userdoc\":{\"events\":{\"LiquidityAction(address,address,uint256,uint256,uint256,bool)\":{\"notice\":\"Emitted when liquidity is added or removed from a pair\"},\"OwnershipTransferred(address,address)\":{\"notice\":\"Emitted when ownership is transferred\"},\"Paused(address)\":{\"notice\":\"Emitted when the contract is paused\"},\"Swap(address,address,uint256,uint256)\":{\"notice\":\"Emitted when tokens are swapped\"},\"Unpaused(address)\":{\"notice\":\"Emitted when the contract is unpaused\"}},\"kind\":\"user\",\"methods\":{\"_getPairHash(address,address)\":{\"notice\":\"Internal function to get a deterministic hash for a token pair\"},\"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)\":{\"notice\":\"Adds liquidity to a token pair pool\"},\"calculateMinOutputWithSlippage(uint256,address[],uint256)\":{\"notice\":\"Advanced slippage protection with custom tolerance\"},\"constructor\":{\"notice\":\"Constructor to set the initial owner\"},\"estimateSwapGas(uint256,address[])\":{\"notice\":\"Estimates the gas cost for a swap operation\"},\"getAmountOut(uint256,uint256,uint256)\":{\"notice\":\"Calculates the output amount for a swap given an input amount and current reserves\"},\"getPrice(address,address)\":{\"notice\":\"Gets the current price of tokenA in terms of tokenB\"},\"getReserves(address,address)\":{\"notice\":\"Gets the current reserve amounts for a token pair\"},\"liquidityBalances(bytes32,address)\":{\"notice\":\"Stores liquidity token balances for each user in each pair\"},\"owner()\":{\"notice\":\"Address of the contract owner who can pause/unpause the contract\"},\"pairs(bytes32)\":{\"notice\":\"Maps a deterministic token pair hash to its PairData\"},\"pause()\":{\"notice\":\"Pauses the contract, preventing new swaps and liquidity operations\"},\"paused()\":{\"notice\":\"Flag indicating if the contract is paused for emergency situations\"},\"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)\":{\"notice\":\"Removes liquidity from a token pair pool\"},\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\":{\"notice\":\"Swaps an exact amount of input tokens for output tokens\"},\"transferOwnership(address)\":{\"notice\":\"Transfers ownership of the contract to a new account\"},\"unpause()\":{\"notice\":\"Unpauses the contract, allowing normal operations to resume\"}},\"notice\":\"An optimized automated market maker (AMM) for token swapping without fees\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SimpleSwap.sol\":\"SimpleSwap\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/SimpleSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title SimpleSwap\\n * @notice An optimized automated market maker (AMM) for token swapping without fees\\n * @dev Implements constant product formula x * y = k without any fees using structs for gas optimization.\\n * This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.\\n * @author Eduardo Moreno - Optimized Version\\n * @custom:security-contact eduardomoreno2503@gmail.com\\n */\\ncontract SimpleSwap {\\n    /// @notice Address of the contract owner who can pause/unpause the contract\\n    address public owner;\\n    \\n    /// @notice Flag indicating if the contract is paused for emergency situations\\n    bool public paused;\\n\\n    /// @notice Struct to store all reserve and liquidity data for a trading pair\\n    /// @dev Packs related data together to minimize storage slots and gas costs\\n    struct PairData {\\n        uint256 reserveA; /// @dev Reserve amount of tokenA in the pair\\n        uint256 reserveB; /// @dev Reserve amount of tokenB in the pair\\n        uint256 totalLiquidity; /// @dev Total liquidity tokens issued for this pair\\n    }\\n\\n    /// @notice Struct to cache storage values during function execution\\n    /// @dev Used to minimize storage reads/writes within functions by loading data once\\n    struct LocalPairData {\\n        uint256 reserveA; /// @dev Local cache of tokenA reserve\\n        uint256 reserveB; /// @dev Local cache of tokenB reserve\\n        uint256 totalLiquidity; /// @dev Local cache of total liquidity\\n        bool isFirstProvision; /// @dev Flag indicating if this is the first liquidity provision\\n    }\\n\\n    /// @notice Maps a deterministic token pair hash to its PairData\\n    /// @dev Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering\\n    /// to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order\\n    mapping(bytes32 => PairData) public pairs;\\n\\n    /// @notice Stores liquidity token balances for each user in each pair\\n    /// @dev Maps pair hash => user address => liquidity balance\\n    mapping(bytes32 => mapping(address => uint256)) public liquidityBalances;\\n\\n    /// @notice Emitted when tokens are swapped\\n    /// @param tokenIn The address of the token sent into the swap\\n    /// @param tokenOut The address of the token received from the swap\\n    /// @param amountIn The amount of tokenIn that was swapped\\n    /// @param amountOut The amount of tokenOut that was received\\n    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\\n\\n    /// @notice Emitted when liquidity is added or removed from a pair\\n    /// @param tokenA The address of the first token in the pair\\n    /// @param tokenB The address of the second token in the pair\\n    /// @param amountA The amount of tokenA involved in the liquidity action\\n    /// @param amountB The amount of tokenB involved in the liquidity action\\n    /// @param liquidity The amount of liquidity tokens minted (if added) or burned (if removed)\\n    /// @param isAdded True if liquidity was added, false if removed\\n    event LiquidityAction(\\n        address indexed tokenA,\\n        address indexed tokenB,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 liquidity,\\n        bool isAdded\\n    );\\n\\n    /// @notice Emitted when the contract is paused\\n    /// @param account The address that triggered the pause\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the contract is unpaused\\n    /// @param account The address that triggered the unpause\\n    event Unpaused(address account);\\n\\n    /// @notice Emitted when ownership is transferred\\n    /// @param previousOwner The address of the previous owner\\n    /// @param newOwner The address of the new owner\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Modifier to restrict access to owner-only functions\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /// @notice Modifier to check if the contract is not paused\\n    modifier whenNotPaused() {\\n        _checkNotPaused();\\n        _;\\n    }\\n\\n    /// @notice Internal function to check if caller is owner (single storage read)\\n    /// @dev Caches owner to ensure single storage access per call\\n    function _checkOwner() internal view {\\n        require(msg.sender == owner, \\\"not owner\\\");\\n    }\\n\\n    /// @notice Internal function to check if contract is not paused (single storage read)\\n    /// @dev Caches paused state to ensure single storage access per call\\n    function _checkNotPaused() internal view {\\n        require(!paused, \\\"paused\\\");\\n    }\\n\\n    /// @notice Constructor to set the initial owner\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Internal function to get a deterministic hash for a token pair\\n     * @dev Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing\\n     * to guarantee the same hash for (A, B) and (B, A)\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @return pairHash The keccak256 hash of the ordered token addresses\\n     * @return reversed True if tokenA and tokenB were reversed to maintain order, false otherwise\\n     */\\n    function _getPairHash(address tokenA, address tokenB) public pure returns (bytes32 pairHash, bool reversed) {\\n        if (tokenA < tokenB) {\\n            return (keccak256(abi.encodePacked(tokenA, tokenB)), false);\\n        } else {\\n            return (keccak256(abi.encodePacked(tokenB, tokenA)), true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to load pair data from storage into a LocalPairData struct\\n     * @dev Reads all relevant pair data in a single storage access to minimize gas costs\\n     * Handles token order reversal for consistent data loading\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @return localData A LocalPairData struct containing the reserves, total liquidity, and first provision status\\n     * @return pairHash The deterministic hash of the token pair\\n     * @return reversed True if tokenA and tokenB were reversed during hash calculation\\n     */\\n    function _loadPairData(\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (LocalPairData memory localData, bytes32 pairHash, bool reversed) {\\n        (pairHash, reversed) = _getPairHash(tokenA, tokenB);\\n        PairData storage pairData = pairs[pairHash]; // Single storage read\\n\\n        // Cache totalLiquidity to avoid multiple reads\\n        uint256 totalLiq = pairData.totalLiquidity;\\n        \\n        // Populate localData based on original or reversed order\\n        if (reversed) {\\n            localData = LocalPairData({\\n                reserveA: pairData.reserveB,\\n                reserveB: pairData.reserveA,\\n                totalLiquidity: totalLiq,\\n                isFirstProvision: totalLiq == 0\\n            });\\n        } else {\\n            localData = LocalPairData({\\n                reserveA: pairData.reserveA,\\n                reserveB: pairData.reserveB,\\n                totalLiquidity: totalLiq,\\n                isFirstProvision: totalLiq == 0\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to save updated pair data from a LocalPairData struct to storage\\n     * @dev Updates all relevant pair data in a single storage write to minimize gas costs\\n     * Handles token order reversal to save data consistently\\n     * @param pairHash The deterministic hash of the token pair\\n     * @param reversed True if tokenA and tokenB were reversed during hash calculation\\n     * @param localData A LocalPairData struct containing the updated reserves and total liquidity\\n     */\\n    function _savePairData(bytes32 pairHash, bool reversed, LocalPairData memory localData) internal {\\n        PairData storage pairData = pairs[pairHash]; // Single storage write\\n\\n        // Save data back to storage, respecting the original order\\n        if (reversed) {\\n            pairData.reserveA = localData.reserveB;\\n            pairData.reserveB = localData.reserveA;\\n        } else {\\n            pairData.reserveA = localData.reserveA;\\n            pairData.reserveB = localData.reserveB;\\n        }\\n        pairData.totalLiquidity = localData.totalLiquidity;\\n    }\\n\\n    /**\\n     * @notice Internal function to calculate the amount of liquidity tokens to mint\\n     * @dev For the first liquidity provision, it uses the square root of the product of amounts\\n     * For subsequent provisions, it calculates the proportional liquidity based on existing reserves\\n     * @param amountA The amount of the first token being added\\n     * @param amountB The amount of the second token being added\\n     * @param localData The current LocalPairData containing reserves and total liquidity\\n     * @return The calculated amount of liquidity tokens to mint\\n     */\\n    function _calculateLiquidity(\\n        uint256 amountA,\\n        uint256 amountB,\\n        LocalPairData memory localData\\n    ) internal pure returns (uint256) {\\n        if (localData.isFirstProvision) {\\n            // First liquidity provision: liquidity is sqrt(amountA * amountB)\\n            return _sqrt(amountA * amountB);\\n        }\\n        // Subsequent liquidity provision: calculate proportional liquidity\\n        return\\n            _min(\\n                (amountA * localData.totalLiquidity) / localData.reserveA,\\n                (amountB * localData.totalLiquidity) / localData.reserveB\\n            );\\n    }\\n\\n    /**\\n     * @notice Adds liquidity to a token pair pool\\n     * @dev Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract,\\n     * calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event\\n     * Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @param amountADesired Amount of first token to add\\n     * @param amountBDesired Amount of second token to add\\n     * @param amountAMin Minimum amount of first token to add, to prevent front-running\\n     * @param amountBMin Minimum amount of second token to add, to prevent front-running\\n     * @param to Address that will receive the liquidity tokens\\n     * @param deadline Maximum timestamp until which the transaction is valid\\n     * @return amountA The actual amount of first token added\\n     * @return amountB The actual amount of second token added\\n     * @return liquidity The amount of liquidity tokens minted\\n     */\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external whenNotPaused returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\\n        require(block.timestamp <= deadline, \\\"exp\\\");\\n        require(amountADesired >= amountAMin && amountBDesired >= amountBMin, \\\"low amt\\\");\\n\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\\n\\n        liquidity = _calculateLiquidity(amountADesired, amountBDesired, data);\\n\\n        _transferFrom(tokenA, msg.sender, address(this), amountADesired);\\n        _transferFrom(tokenB, msg.sender, address(this), amountBDesired);\\n\\n        // Update reserves and total liquidity in local data\\n        data.reserveA += amountADesired;\\n        data.reserveB += amountBDesired;\\n        data.totalLiquidity += liquidity;\\n\\n        _savePairData(hash, rev, data);\\n        liquidityBalances[hash][to] += liquidity;\\n\\n        emit LiquidityAction(tokenA, tokenB, amountADesired, amountBDesired, liquidity, true);\\n        return (amountADesired, amountBDesired, liquidity);\\n    }\\n\\n    /**\\n     * @notice Removes liquidity from a token pair pool\\n     * @dev Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB`\\n     * back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event\\n     * Requires the received amounts to be at least `amountAMin` and `amountBMin`\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @param liquidity Amount of liquidity tokens to burn\\n     * @param amountAMin Minimum amount of first token to receive, to prevent front-running\\n     * @param amountBMin Minimum amount of second token to receive, to prevent front-running\\n     * @param to Address that will receive the tokens\\n     * @param deadline Maximum timestamp until which the transaction is valid\\n     * @return amountA The actual amount of first token returned\\n     * @return amountB The actual amount of second token returned\\n     */\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external whenNotPaused returns (uint256 amountA, uint256 amountB) {\\n        require(block.timestamp <= deadline, \\\"exp\\\");\\n\\n        // Load data once to check liquidity balance before further calculations\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(tokenA, tokenB);\\n        \\n        // Cache liquidity balance to avoid multiple reads\\n        uint256 userLiq = liquidityBalances[hash][msg.sender];\\n        require(userLiq >= liquidity, \\\"low liq\\\");\\n\\n        amountA = (liquidity * data.reserveA) / data.totalLiquidity;\\n        amountB = (liquidity * data.reserveB) / data.totalLiquidity;\\n        require(amountA >= amountAMin && amountB >= amountBMin, \\\"low amt\\\");\\n\\n        // Update reserves and total liquidity in local data\\n        data.reserveA -= amountA;\\n        data.reserveB -= amountB;\\n        data.totalLiquidity -= liquidity;\\n\\n        _savePairData(hash, rev, data);\\n        liquidityBalances[hash][msg.sender] = userLiq - liquidity;\\n\\n        _transfer(tokenA, to, amountA);\\n        _transfer(tokenB, to, amountB);\\n\\n        emit LiquidityAction(tokenA, tokenB, amountA, amountB, liquidity, false);\\n    }\\n\\n    /**\\n     * @notice Swaps an exact amount of input tokens for output tokens\\n     * @dev Transfers `amountIn` of `path[0]` from `msg.sender` to the contract,\\n     * calculates the output amount of `path[1]`, transfers `amountOut` to `to` address,\\n     * updates reserves, and emits a `Swap` event\\n     * Requires `amountOut` to be at least `amountOutMin`\\n     * @param amountIn Amount of input tokens to swap\\n     * @param amountOutMin Minimum amount of output tokens to receive, to prevent front-running\\n     * @param path Array containing [tokenIn, tokenOut] addresses\\n     * @param to Address that will receive the output tokens\\n     * @param deadline Maximum timestamp until which the transaction is valid\\n     */\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external whenNotPaused {\\n        require(block.timestamp <= deadline, \\\"exp\\\");\\n        require(path.length == 2, \\\"bad len\\\");\\n\\n        // Load data once\\n        (LocalPairData memory data, bytes32 hash, bool rev) = _loadPairData(path[0], path[1]);\\n\\n        // Load pair data and calculate output without any fees\\n\\n        // No fees applied - using direct amountIn for AMM calculation\\n\\n        uint256 amountOut = getAmountOut(amountIn, data.reserveA, data.reserveB);\\n        require(amountOut >= amountOutMin, \\\"low out\\\");\\n\\n        _transferFrom(path[0], msg.sender, address(this), amountIn);\\n\\n        // Update reserves in local data\\n        data.reserveA += amountIn; // Add input amount to reserves\\n        data.reserveB -= amountOut;\\n\\n        _savePairData(hash, rev, data);\\n        _transfer(path[1], to, amountOut);\\n\\n        emit Swap(path[0], path[1], amountIn, amountOut);\\n    }\\n\\n    /**\\n     * @notice Gets the current price of tokenA in terms of tokenB\\n     * @dev Calculates the price based on the current reserves of the pair\\n     * The price is returned as a fixed-point number with 18 decimal places (wei equivalent)\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @return price Price of tokenA in terms of tokenB, scaled by 1e18\\n     */\\n    function getPrice(address tokenA, address tokenB) external view returns (uint256 price) {\\n        (LocalPairData memory data, , ) = _loadPairData(tokenA, tokenB);\\n        // Ensure reserves are not zero to prevent division by zero\\n        require(data.reserveA > 0, \\\"no res\\\");\\n        return (data.reserveB * 1e18) / data.reserveA;\\n    }\\n\\n    /**\\n     * @notice Gets the current reserve amounts for a token pair\\n     * @dev Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair\\n     * @param tokenA Address of the first token\\n     * @param tokenB Address of the second token\\n     * @return reserveA The current reserve amount of the first token\\n     * @return reserveB The current reserve amount of the second token\\n     */\\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB) {\\n        (LocalPairData memory data, , ) = _loadPairData(tokenA, tokenB);\\n        return (data.reserveA, data.reserveB);\\n    }\\n\\n    /**\\n     * @notice Calculates the output amount for a swap given an input amount and current reserves\\n     * @dev Implements the constant product formula (x * y = k) to determine the amount of output tokens\\n     * received for a given amount of input tokens\\n     * @param amountIn Amount of input tokens\\n     * @param reserveIn Reserve of the input token\\n     * @param reserveOut Reserve of the output token\\n     * @return amountOut Amount of output tokens to receive\\n     */\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public pure returns (uint256) {\\n        require(amountIn > 0, \\\"bad amt\\\");\\n        require(reserveIn > 0, \\\"bad amt\\\");\\n        require(reserveOut > 0, \\\"bad amt\\\");\\n        return (amountIn * reserveOut) / (reserveIn + amountIn);\\n    }\\n\\n    /**\\n     * @dev Internal function to handle `transferFrom` operations for ERC-20 tokens\\n     * Assumes the `token` address is a valid ERC-20 contract\\n     * @param token The address of the ERC-20 token contract\\n     * @param from The address from which tokens are transferred\\n     * @param to The address to which tokens are transferred\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function _transferFrom(address token, address from, address to, uint256 amount) internal {\\n        (bool success, ) = token.call(\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", from, to, amount)\\n        );\\n        require(success, \\\"tf fail\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to handle `transfer` operations for ERC-20 tokens\\n     * Assumes the `token` address is a valid ERC-20 contract\\n     * @param token The address of the ERC-20 token contract\\n     * @param to The address to which tokens are transferred\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function _transfer(address token, address to, uint256 amount) internal {\\n        (bool success, ) = token.call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", to, amount));\\n        require(success, \\\"t fail\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate the integer square root of a number\\n     * Used for initial liquidity calculation\\n     * @param y The number for which to calculate the square root\\n     * @return z The integer square root of y\\n     */\\n    function _sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to return the minimum of two unsigned integers\\n     * @param x The first number\\n     * @param y The second number\\n     * @return The smaller of x and y\\n     */\\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /**\\n     * @notice Pauses the contract, preventing new swaps and liquidity operations\\n     * @dev Only the owner can call this function during emergency situations\\n     */\\n    function pause() external onlyOwner {\\n        paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract, allowing normal operations to resume\\n     * @dev Only the owner can call this function to resume operations\\n     */\\n    function unpause() external onlyOwner {\\n        paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account\\n     * @dev Only the current owner can call this function\\n     * @param newOwner The address of the new owner\\n     */\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"zero\\\");\\n        address previousOwner = owner; // Cache current owner to avoid multiple storage reads\\n        emit OwnershipTransferred(previousOwner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    /**\\n     * @notice Estimates the gas cost for a swap operation\\n     * @dev Provides gas estimation without executing the actual swap\\n     * @param amountIn Amount of input tokens to swap\\n     * @param path Array containing [tokenIn, tokenOut] addresses\\n     * @return gasEstimate Estimated gas cost for the swap operation\\n     */\\n    function estimateSwapGas(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256 gasEstimate) {\\n        require(path.length == 2, \\\"bad len\\\");\\n        \\n        (LocalPairData memory data, , ) = _loadPairData(path[0], path[1]);\\n        require(data.reserveA > 0 && data.reserveB > 0, \\\"no liq\\\");\\n        \\n        uint256 amountOut = getAmountOut(amountIn, data.reserveA, data.reserveB);\\n        require(amountOut > 0, \\\"no out\\\");\\n        \\n        // Base gas cost for swap operation (empirically determined)\\n        return 85000; // Approximate gas cost for swapExactTokensForTokens\\n    }\\n\\n    /**\\n     * @notice Advanced slippage protection with custom tolerance\\n     * @dev Calculates minimum output with slippage tolerance in basis points\\n     * @param amountIn Amount of input tokens\\n     * @param path Array containing [tokenIn, tokenOut] addresses  \\n     * @param slippageBps Slippage tolerance in basis points (100 = 1%)\\n     * @return amountOutMin Minimum output amount considering slippage\\n     */\\n    function calculateMinOutputWithSlippage(\\n        uint256 amountIn,\\n        address[] calldata path,\\n        uint256 slippageBps\\n    ) external view returns (uint256 amountOutMin) {\\n        require(path.length == 2, \\\"bad len\\\");\\n        require(slippageBps <= 5000, \\\"hi slip\\\"); // Max 50% slippage\\n        \\n        (LocalPairData memory data, , ) = _loadPairData(path[0], path[1]);\\n        uint256 amountOut = getAmountOut(amountIn, data.reserveA, data.reserveB);\\n        \\n        // Apply slippage: amountOut * (10000 - slippageBps) / 10000\\n        return (amountOut * (10000 - slippageBps)) / 10000;\\n    }\\n}\\n\",\"keccak256\":\"0x0fbbb1f7f299e35b6f875bad91d3bdc93627e01f436820435d09a698ee7e4bff\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50600080546001600160a01b0319163390811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a361166e8061005f6000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80638da5cb5b11610097578063d52bb6f411610066578063d52bb6f414610274578063e8e3370014610287578063e9fe6f2b1461029a578063f2fde38b146102c257600080fd5b80638da5cb5b146101fb578063ac41865a14610226578063baa2abde14610239578063d366c5b81461026157600080fd5b80634fb5bf7f116100d35780634fb5bf7f1461015b5780635c975abb14610186578063673e0481146101aa5780638456cb59146101f357600080fd5b8063054d50d4146101055780632ec865bb1461012b57806338ed17391461013e5780633f4ba83a14610153575b600080fd5b610118610113366004611220565b6102d5565b6040519081526020015b60405180910390f35b610118610139366004611291565b610367565b61015161014c3660046112fb565b610466565b005b610151610694565b61011861016936600461136b565b600260209081526000928352604080842090915290825290205481565b60005461019a90600160a01b900460ff1681565b6040519015158152602001610122565b6101d86101b8366004611397565b600160208190526000918252604090912080549181015460029091015483565b60408051938452602084019290925290820152606001610122565b6101516106df565b60005461020e906001600160a01b031681565b6040516001600160a01b039091168152602001610122565b6101186102343660046113b0565b61072a565b61024c6102473660046113da565b6107a0565b60408051928352602083019190915201610122565b61011861026f366004611444565b6109aa565b61024c6102823660046113b0565b610ab8565b6101d8610295366004611490565b610adf565b6102ad6102a83660046113b0565b610c92565b60408051928352901515602083015201610122565b6101516102d0366004611504565b610d43565b60008084116102ff5760405162461bcd60e51b81526004016102f69061151f565b60405180910390fd5b6000831161031f5760405162461bcd60e51b81526004016102f69061151f565b6000821161033f5760405162461bcd60e51b81526004016102f69061151f565b6103498484611556565b6103538386611569565b61035d9190611580565b90505b9392505050565b6000600283146103895760405162461bcd60e51b81526004016102f6906115a2565b6113888211156103c55760405162461bcd60e51b81526020600482015260076024820152660686920736c69760cc1b60448201526064016102f6565b600061041f858560008181106103dd576103dd6115c3565b90506020020160208101906103f29190611504565b86866001818110610405576104056115c3565b905060200201602081019061041a9190611504565b610dea565b50509050600061043887836000015184602001516102d5565b905061271061044785826115d9565b6104519083611569565b61045b9190611580565b979650505050505050565b61046e610ea1565b8042111561048e5760405162461bcd60e51b81526004016102f6906115ec565b600283146104ae5760405162461bcd60e51b81526004016102f6906115a2565b60008060006104f1878760008181106104c9576104c96115c3565b90506020020160208101906104de9190611504565b88886001818110610405576104056115c3565b925092509250600061050c8a856000015186602001516102d5565b9050888110156105485760405162461bcd60e51b81526020600482015260076024820152661b1bddc81bdd5d60ca1b60448201526064016102f6565b61057b8888600081811061055e5761055e6115c3565b90506020020160208101906105739190611504565b33308d610ee6565b898460000181815161058d9190611556565b9052506020840180518291906105a49083906115d9565b9052506105b2838386610fcb565b6105e4888860018181106105c8576105c86115c3565b90506020020160208101906105dd9190611504565b8783611011565b878760018181106105f7576105f76115c3565b905060200201602081019061060c9190611504565b6001600160a01b031688886000818110610628576106286115c3565b905060200201602081019061063d9190611504565b6001600160a01b03167ffa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe2358c84604051610680929190918252602082015260400190565b60405180910390a350505050505050505050565b61069c6110ec565b6000805460ff60a01b191690556040513381527f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa906020015b60405180910390a1565b6106e76110ec565b6000805460ff60a01b1916600160a01b1790556040513381527f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258906020016106d5565b6000806107378484610dea565b505080519091506107735760405162461bcd60e51b81526020600482015260066024820152656e6f2072657360d01b60448201526064016102f6565b8051602082015161078c90670de0b6b3a7640000611569565b6107969190611580565b9150505b92915050565b6000806107ab610ea1565b824211156107cb5760405162461bcd60e51b81526004016102f6906115ec565b60008060006107da8c8c610dea565b600082815260026020908152604080832033845290915290205492955090935091508a8110156108365760405162461bcd60e51b81526020600482015260076024820152666c6f77206c697160c81b60448201526064016102f6565b60408401518451610847908d611569565b6108519190611580565b9550836040015184602001518c6108689190611569565b6108729190611580565b94508986101580156108845750888510155b6108ba5760405162461bcd60e51b81526020600482015260076024820152661b1bddc8185b5d60ca1b60448201526064016102f6565b85846000018181516108cc91906115d9565b9052506020840180518691906108e39083906115d9565b9052506040840180518c91906108fa9083906115d9565b905250610908838386610fcb565b6109128b826115d9565b60008481526002602090815260408083203384529091529020556109378d8988611011565b6109428c8987611011565b60408051878152602081018790529081018c9052600060608201526001600160a01b03808e1691908f16907fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a9060800160405180910390a35050505097509795505050505050565b6000600282146109cc5760405162461bcd60e51b81526004016102f6906115a2565b6000610a0c848460008181106109e4576109e46115c3565b90506020020160208101906109f99190611504565b85856001818110610405576104056115c3565b5050805190915015801590610a25575060008160200151115b610a5a5760405162461bcd60e51b81526020600482015260066024820152656e6f206c697160d01b60448201526064016102f6565b6000610a6f86836000015184602001516102d5565b905060008111610aaa5760405162461bcd60e51b81526020600482015260066024820152651b9bc81bdd5d60d21b60448201526064016102f6565b5062014c0895945050505050565b6000806000610ac78585610dea565b505080516020909101519093509150505b9250929050565b6000806000610aec610ea1565b83421115610b0c5760405162461bcd60e51b81526004016102f6906115ec565b868910158015610b1c5750858810155b610b525760405162461bcd60e51b81526020600482015260076024820152661b1bddc8185b5d60ca1b60448201526064016102f6565b6000806000610b618e8e610dea565b925092509250610b728c8c85611132565b9350610b808e33308f610ee6565b610b8c8d33308e610ee6565b8b83600001818151610b9e9190611556565b9052506020830180518c9190610bb5908390611556565b905250604083018051859190610bcc908390611556565b905250610bda828285610fcb565b60008281526002602090815260408083206001600160a01b038c16845290915281208054869290610c0c908490611556565b925050819055508c6001600160a01b03168e6001600160a01b03167fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a8e8e886001604051610c759493929190938452602084019290925260408301521515606082015260800190565b60405180910390a350999c989b5090995096975050505050505050565b600080826001600160a01b0316846001600160a01b03161015610cf9576040516bffffffffffffffffffffffff19606086811b8216602084015285901b16603482015260480160405160208183030381529060405280519060200120600091509150610ad8565b6040516bffffffffffffffffffffffff19606085811b8216602084015286901b16603482015260480160405160208183030381529060405280519060200120600191509150610ad8565b610d4b6110ec565b6001600160a01b038116610d8a5760405162461bcd60e51b81526004016102f6906020808252600490820152637a65726f60e01b604082015260600190565b600080546040516001600160a01b03918216929184169183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350600080546001600160a01b0319166001600160a01b0392909216919091179055565b610e1760405180608001604052806000815260200160008152602001600081526020016000151581525090565b600080610e248585610c92565b60008281526001602052604090206002810154929450909250908215610e7057604080516080810182526001840154815283546020820152908101829052811560608201529450610e98565b6040805160808101825283548152600184015460208201529081018290528115606082015294505b50509250925092565b600054600160a01b900460ff1615610ee45760405162461bcd60e51b81526020600482015260066024820152651c185d5cd95960d21b60448201526064016102f6565b565b6040516001600160a01b0384811660248301528381166044830152606482018390526000919086169060840160408051601f198184030181529181526020820180516001600160e01b03166323b872dd60e01b17905251610f479190611609565b6000604051808303816000865af19150503d8060008114610f84576040519150601f19603f3d011682016040523d82523d6000602084013e610f89565b606091505b5050905080610fc45760405162461bcd60e51b81526020600482015260076024820152661d198819985a5b60ca1b60448201526064016102f6565b5050505050565b60008381526001602052604090208215610ff2576020820151815581516001820155611001565b81518155602082015160018201555b6040909101516002909101555050565b6040516001600160a01b038381166024830152604482018390526000919085169060640160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b1790525161106a9190611609565b6000604051808303816000865af19150503d80600081146110a7576040519150601f19603f3d011682016040523d82523d6000602084013e6110ac565b606091505b50509050806110e65760405162461bcd60e51b81526020600482015260066024820152651d0819985a5b60d21b60448201526064016102f6565b50505050565b6000546001600160a01b03163314610ee45760405162461bcd60e51b81526020600482015260096024820152683737ba1037bbb732b960b91b60448201526064016102f6565b60008160600151156111575761115061114b8486611569565b61119a565b9050610360565b8151604083015161035d919061116d9087611569565b6111779190611580565b6020840151604085015161118b9087611569565b6111959190611580565b61120a565b600060038211156111fb57508060006111b4600283611580565b6111bf906001611556565b90505b818110156111f5579050806002816111da8186611580565b6111e49190611556565b6111ee9190611580565b90506111c2565b50919050565b8115611205575060015b919050565b60008183106112195781610360565b5090919050565b60008060006060848603121561123557600080fd5b505081359360208301359350604090920135919050565b60008083601f84011261125e57600080fd5b50813567ffffffffffffffff81111561127657600080fd5b6020830191508360208260051b8501011115610ad857600080fd5b600080600080606085870312156112a757600080fd5b84359350602085013567ffffffffffffffff8111156112c557600080fd5b6112d18782880161124c565b9598909750949560400135949350505050565b80356001600160a01b038116811461120557600080fd5b60008060008060008060a0878903121561131457600080fd5b8635955060208701359450604087013567ffffffffffffffff81111561133957600080fd5b61134589828a0161124c565b90955093506113589050606088016112e4565b9150608087013590509295509295509295565b6000806040838503121561137e57600080fd5b8235915061138e602084016112e4565b90509250929050565b6000602082840312156113a957600080fd5b5035919050565b600080604083850312156113c357600080fd5b6113cc836112e4565b915061138e602084016112e4565b600080600080600080600060e0888a0312156113f557600080fd5b6113fe886112e4565b965061140c602089016112e4565b955060408801359450606088013593506080880135925061142f60a089016112e4565b915060c0880135905092959891949750929550565b60008060006040848603121561145957600080fd5b83359250602084013567ffffffffffffffff81111561147757600080fd5b6114838682870161124c565b9497909650939450505050565b600080600080600080600080610100898b0312156114ad57600080fd5b6114b6896112e4565b97506114c460208a016112e4565b965060408901359550606089013594506080890135935060a089013592506114ee60c08a016112e4565b915060e089013590509295985092959890939650565b60006020828403121561151657600080fd5b610360826112e4565b60208082526007908201526618985908185b5d60ca1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561079a5761079a611540565b808202811582820484141761079a5761079a611540565b60008261159d57634e487b7160e01b600052601260045260246000fd5b500490565b6020808252600790820152663130b2103632b760c91b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b8181038181111561079a5761079a611540565b60208082526003908201526206578760ec1b604082015260600190565b6000825160005b8181101561162a5760208186018101518583015201611610565b50600092019182525091905056fea26469706673582212201de767afb1ac10edb729a27b8929568489ef5b957ef6522b31490d8c66d96b9b64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80638da5cb5b11610097578063d52bb6f411610066578063d52bb6f414610274578063e8e3370014610287578063e9fe6f2b1461029a578063f2fde38b146102c257600080fd5b80638da5cb5b146101fb578063ac41865a14610226578063baa2abde14610239578063d366c5b81461026157600080fd5b80634fb5bf7f116100d35780634fb5bf7f1461015b5780635c975abb14610186578063673e0481146101aa5780638456cb59146101f357600080fd5b8063054d50d4146101055780632ec865bb1461012b57806338ed17391461013e5780633f4ba83a14610153575b600080fd5b610118610113366004611220565b6102d5565b6040519081526020015b60405180910390f35b610118610139366004611291565b610367565b61015161014c3660046112fb565b610466565b005b610151610694565b61011861016936600461136b565b600260209081526000928352604080842090915290825290205481565b60005461019a90600160a01b900460ff1681565b6040519015158152602001610122565b6101d86101b8366004611397565b600160208190526000918252604090912080549181015460029091015483565b60408051938452602084019290925290820152606001610122565b6101516106df565b60005461020e906001600160a01b031681565b6040516001600160a01b039091168152602001610122565b6101186102343660046113b0565b61072a565b61024c6102473660046113da565b6107a0565b60408051928352602083019190915201610122565b61011861026f366004611444565b6109aa565b61024c6102823660046113b0565b610ab8565b6101d8610295366004611490565b610adf565b6102ad6102a83660046113b0565b610c92565b60408051928352901515602083015201610122565b6101516102d0366004611504565b610d43565b60008084116102ff5760405162461bcd60e51b81526004016102f69061151f565b60405180910390fd5b6000831161031f5760405162461bcd60e51b81526004016102f69061151f565b6000821161033f5760405162461bcd60e51b81526004016102f69061151f565b6103498484611556565b6103538386611569565b61035d9190611580565b90505b9392505050565b6000600283146103895760405162461bcd60e51b81526004016102f6906115a2565b6113888211156103c55760405162461bcd60e51b81526020600482015260076024820152660686920736c69760cc1b60448201526064016102f6565b600061041f858560008181106103dd576103dd6115c3565b90506020020160208101906103f29190611504565b86866001818110610405576104056115c3565b905060200201602081019061041a9190611504565b610dea565b50509050600061043887836000015184602001516102d5565b905061271061044785826115d9565b6104519083611569565b61045b9190611580565b979650505050505050565b61046e610ea1565b8042111561048e5760405162461bcd60e51b81526004016102f6906115ec565b600283146104ae5760405162461bcd60e51b81526004016102f6906115a2565b60008060006104f1878760008181106104c9576104c96115c3565b90506020020160208101906104de9190611504565b88886001818110610405576104056115c3565b925092509250600061050c8a856000015186602001516102d5565b9050888110156105485760405162461bcd60e51b81526020600482015260076024820152661b1bddc81bdd5d60ca1b60448201526064016102f6565b61057b8888600081811061055e5761055e6115c3565b90506020020160208101906105739190611504565b33308d610ee6565b898460000181815161058d9190611556565b9052506020840180518291906105a49083906115d9565b9052506105b2838386610fcb565b6105e4888860018181106105c8576105c86115c3565b90506020020160208101906105dd9190611504565b8783611011565b878760018181106105f7576105f76115c3565b905060200201602081019061060c9190611504565b6001600160a01b031688886000818110610628576106286115c3565b905060200201602081019061063d9190611504565b6001600160a01b03167ffa2dda1cc1b86e41239702756b13effbc1a092b5c57e3ad320fbe4f3b13fe2358c84604051610680929190918252602082015260400190565b60405180910390a350505050505050505050565b61069c6110ec565b6000805460ff60a01b191690556040513381527f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa906020015b60405180910390a1565b6106e76110ec565b6000805460ff60a01b1916600160a01b1790556040513381527f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258906020016106d5565b6000806107378484610dea565b505080519091506107735760405162461bcd60e51b81526020600482015260066024820152656e6f2072657360d01b60448201526064016102f6565b8051602082015161078c90670de0b6b3a7640000611569565b6107969190611580565b9150505b92915050565b6000806107ab610ea1565b824211156107cb5760405162461bcd60e51b81526004016102f6906115ec565b60008060006107da8c8c610dea565b600082815260026020908152604080832033845290915290205492955090935091508a8110156108365760405162461bcd60e51b81526020600482015260076024820152666c6f77206c697160c81b60448201526064016102f6565b60408401518451610847908d611569565b6108519190611580565b9550836040015184602001518c6108689190611569565b6108729190611580565b94508986101580156108845750888510155b6108ba5760405162461bcd60e51b81526020600482015260076024820152661b1bddc8185b5d60ca1b60448201526064016102f6565b85846000018181516108cc91906115d9565b9052506020840180518691906108e39083906115d9565b9052506040840180518c91906108fa9083906115d9565b905250610908838386610fcb565b6109128b826115d9565b60008481526002602090815260408083203384529091529020556109378d8988611011565b6109428c8987611011565b60408051878152602081018790529081018c9052600060608201526001600160a01b03808e1691908f16907fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a9060800160405180910390a35050505097509795505050505050565b6000600282146109cc5760405162461bcd60e51b81526004016102f6906115a2565b6000610a0c848460008181106109e4576109e46115c3565b90506020020160208101906109f99190611504565b85856001818110610405576104056115c3565b5050805190915015801590610a25575060008160200151115b610a5a5760405162461bcd60e51b81526020600482015260066024820152656e6f206c697160d01b60448201526064016102f6565b6000610a6f86836000015184602001516102d5565b905060008111610aaa5760405162461bcd60e51b81526020600482015260066024820152651b9bc81bdd5d60d21b60448201526064016102f6565b5062014c0895945050505050565b6000806000610ac78585610dea565b505080516020909101519093509150505b9250929050565b6000806000610aec610ea1565b83421115610b0c5760405162461bcd60e51b81526004016102f6906115ec565b868910158015610b1c5750858810155b610b525760405162461bcd60e51b81526020600482015260076024820152661b1bddc8185b5d60ca1b60448201526064016102f6565b6000806000610b618e8e610dea565b925092509250610b728c8c85611132565b9350610b808e33308f610ee6565b610b8c8d33308e610ee6565b8b83600001818151610b9e9190611556565b9052506020830180518c9190610bb5908390611556565b905250604083018051859190610bcc908390611556565b905250610bda828285610fcb565b60008281526002602090815260408083206001600160a01b038c16845290915281208054869290610c0c908490611556565b925050819055508c6001600160a01b03168e6001600160a01b03167fc5e67c7ae420081af6dc91dd07066f572593e63310dab226cf38c43fdb15026a8e8e886001604051610c759493929190938452602084019290925260408301521515606082015260800190565b60405180910390a350999c989b5090995096975050505050505050565b600080826001600160a01b0316846001600160a01b03161015610cf9576040516bffffffffffffffffffffffff19606086811b8216602084015285901b16603482015260480160405160208183030381529060405280519060200120600091509150610ad8565b6040516bffffffffffffffffffffffff19606085811b8216602084015286901b16603482015260480160405160208183030381529060405280519060200120600191509150610ad8565b610d4b6110ec565b6001600160a01b038116610d8a5760405162461bcd60e51b81526004016102f6906020808252600490820152637a65726f60e01b604082015260600190565b600080546040516001600160a01b03918216929184169183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350600080546001600160a01b0319166001600160a01b0392909216919091179055565b610e1760405180608001604052806000815260200160008152602001600081526020016000151581525090565b600080610e248585610c92565b60008281526001602052604090206002810154929450909250908215610e7057604080516080810182526001840154815283546020820152908101829052811560608201529450610e98565b6040805160808101825283548152600184015460208201529081018290528115606082015294505b50509250925092565b600054600160a01b900460ff1615610ee45760405162461bcd60e51b81526020600482015260066024820152651c185d5cd95960d21b60448201526064016102f6565b565b6040516001600160a01b0384811660248301528381166044830152606482018390526000919086169060840160408051601f198184030181529181526020820180516001600160e01b03166323b872dd60e01b17905251610f479190611609565b6000604051808303816000865af19150503d8060008114610f84576040519150601f19603f3d011682016040523d82523d6000602084013e610f89565b606091505b5050905080610fc45760405162461bcd60e51b81526020600482015260076024820152661d198819985a5b60ca1b60448201526064016102f6565b5050505050565b60008381526001602052604090208215610ff2576020820151815581516001820155611001565b81518155602082015160018201555b6040909101516002909101555050565b6040516001600160a01b038381166024830152604482018390526000919085169060640160408051601f198184030181529181526020820180516001600160e01b031663a9059cbb60e01b1790525161106a9190611609565b6000604051808303816000865af19150503d80600081146110a7576040519150601f19603f3d011682016040523d82523d6000602084013e6110ac565b606091505b50509050806110e65760405162461bcd60e51b81526020600482015260066024820152651d0819985a5b60d21b60448201526064016102f6565b50505050565b6000546001600160a01b03163314610ee45760405162461bcd60e51b81526020600482015260096024820152683737ba1037bbb732b960b91b60448201526064016102f6565b60008160600151156111575761115061114b8486611569565b61119a565b9050610360565b8151604083015161035d919061116d9087611569565b6111779190611580565b6020840151604085015161118b9087611569565b6111959190611580565b61120a565b600060038211156111fb57508060006111b4600283611580565b6111bf906001611556565b90505b818110156111f5579050806002816111da8186611580565b6111e49190611556565b6111ee9190611580565b90506111c2565b50919050565b8115611205575060015b919050565b60008183106112195781610360565b5090919050565b60008060006060848603121561123557600080fd5b505081359360208301359350604090920135919050565b60008083601f84011261125e57600080fd5b50813567ffffffffffffffff81111561127657600080fd5b6020830191508360208260051b8501011115610ad857600080fd5b600080600080606085870312156112a757600080fd5b84359350602085013567ffffffffffffffff8111156112c557600080fd5b6112d18782880161124c565b9598909750949560400135949350505050565b80356001600160a01b038116811461120557600080fd5b60008060008060008060a0878903121561131457600080fd5b8635955060208701359450604087013567ffffffffffffffff81111561133957600080fd5b61134589828a0161124c565b90955093506113589050606088016112e4565b9150608087013590509295509295509295565b6000806040838503121561137e57600080fd5b8235915061138e602084016112e4565b90509250929050565b6000602082840312156113a957600080fd5b5035919050565b600080604083850312156113c357600080fd5b6113cc836112e4565b915061138e602084016112e4565b600080600080600080600060e0888a0312156113f557600080fd5b6113fe886112e4565b965061140c602089016112e4565b955060408801359450606088013593506080880135925061142f60a089016112e4565b915060c0880135905092959891949750929550565b60008060006040848603121561145957600080fd5b83359250602084013567ffffffffffffffff81111561147757600080fd5b6114838682870161124c565b9497909650939450505050565b600080600080600080600080610100898b0312156114ad57600080fd5b6114b6896112e4565b97506114c460208a016112e4565b965060408901359550606089013594506080890135935060a089013592506114ee60c08a016112e4565b915060e089013590509295985092959890939650565b60006020828403121561151657600080fd5b610360826112e4565b60208082526007908201526618985908185b5d60ca1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561079a5761079a611540565b808202811582820484141761079a5761079a611540565b60008261159d57634e487b7160e01b600052601260045260246000fd5b500490565b6020808252600790820152663130b2103632b760c91b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b8181038181111561079a5761079a611540565b60208082526003908201526206578760ec1b604082015260600190565b6000825160005b8181101561162a5760208186018101518583015201611610565b50600092019182525091905056fea26469706673582212201de767afb1ac10edb729a27b8929568489ef5b957ef6522b31490d8c66d96b9b64736f6c63430008140033",
  "devdoc": {
    "author": "Eduardo Moreno - Optimized Version",
    "custom:security-contact": "eduardomoreno2503@gmail.com",
    "details": "Implements constant product formula x * y = k without any fees using structs for gas optimization. This contract allows users to add/remove liquidity and swap between two tokens using single storage access per function.",
    "events": {
      "LiquidityAction(address,address,uint256,uint256,uint256,bool)": {
        "params": {
          "amountA": "The amount of tokenA involved in the liquidity action",
          "amountB": "The amount of tokenB involved in the liquidity action",
          "isAdded": "True if liquidity was added, false if removed",
          "liquidity": "The amount of liquidity tokens minted (if added) or burned (if removed)",
          "tokenA": "The address of the first token in the pair",
          "tokenB": "The address of the second token in the pair"
        }
      },
      "OwnershipTransferred(address,address)": {
        "params": {
          "newOwner": "The address of the new owner",
          "previousOwner": "The address of the previous owner"
        }
      },
      "Paused(address)": {
        "params": {
          "account": "The address that triggered the pause"
        }
      },
      "Swap(address,address,uint256,uint256)": {
        "params": {
          "amountIn": "The amount of tokenIn that was swapped",
          "amountOut": "The amount of tokenOut that was received",
          "tokenIn": "The address of the token sent into the swap",
          "tokenOut": "The address of the token received from the swap"
        }
      },
      "Unpaused(address)": {
        "params": {
          "account": "The address that triggered the unpause"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "_getPairHash(address,address)": {
        "details": "Ensures consistent ordering of token addresses (tokenA < tokenB) before hashing to guarantee the same hash for (A, B) and (B, A)",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "pairHash": "The keccak256 hash of the ordered token addresses",
          "reversed": "True if tokenA and tokenB were reversed to maintain order, false otherwise"
        }
      },
      "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
        "details": "Transfers `amountADesired` and `amountBDesired` from `msg.sender` to the contract, calculates the liquidity tokens to mint, updates reserves, and emits a `LiquidityAction` event Requires `amountADesired` and `amountBDesired` to be at least `amountAMin` and `amountBMin` respectively",
        "params": {
          "amountADesired": "Amount of first token to add",
          "amountAMin": "Minimum amount of first token to add, to prevent front-running",
          "amountBDesired": "Amount of second token to add",
          "amountBMin": "Minimum amount of second token to add, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "to": "Address that will receive the liquidity tokens",
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "amountA": "The actual amount of first token added",
          "amountB": "The actual amount of second token added",
          "liquidity": "The amount of liquidity tokens minted"
        }
      },
      "calculateMinOutputWithSlippage(uint256,address[],uint256)": {
        "details": "Calculates minimum output with slippage tolerance in basis points",
        "params": {
          "amountIn": "Amount of input tokens",
          "path": "Array containing [tokenIn, tokenOut] addresses  ",
          "slippageBps": "Slippage tolerance in basis points (100 = 1%)"
        },
        "returns": {
          "amountOutMin": "Minimum output amount considering slippage"
        }
      },
      "estimateSwapGas(uint256,address[])": {
        "details": "Provides gas estimation without executing the actual swap",
        "params": {
          "amountIn": "Amount of input tokens to swap",
          "path": "Array containing [tokenIn, tokenOut] addresses"
        },
        "returns": {
          "gasEstimate": "Estimated gas cost for the swap operation"
        }
      },
      "getAmountOut(uint256,uint256,uint256)": {
        "details": "Implements the constant product formula (x * y = k) to determine the amount of output tokens received for a given amount of input tokens",
        "params": {
          "amountIn": "Amount of input tokens",
          "reserveIn": "Reserve of the input token",
          "reserveOut": "Reserve of the output token"
        },
        "returns": {
          "_0": "amountOut Amount of output tokens to receive"
        }
      },
      "getPrice(address,address)": {
        "details": "Calculates the price based on the current reserves of the pair The price is returned as a fixed-point number with 18 decimal places (wei equivalent)",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "price": "Price of tokenA in terms of tokenB, scaled by 1e18"
        }
      },
      "getReserves(address,address)": {
        "details": "Retrieves the amounts of tokenA and tokenB held in the contract's reserves for a given pair",
        "params": {
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "reserveA": "The current reserve amount of the first token",
          "reserveB": "The current reserve amount of the second token"
        }
      },
      "pause()": {
        "details": "Only the owner can call this function during emergency situations"
      },
      "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
        "details": "Burns `liquidity` tokens from `msg.sender` and transfers proportional amounts of `tokenA` and `tokenB` back to the `to` address. Updates reserves and total liquidity, and emits a `LiquidityAction` event Requires the received amounts to be at least `amountAMin` and `amountBMin`",
        "params": {
          "amountAMin": "Minimum amount of first token to receive, to prevent front-running",
          "amountBMin": "Minimum amount of second token to receive, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "liquidity": "Amount of liquidity tokens to burn",
          "to": "Address that will receive the tokens",
          "tokenA": "Address of the first token",
          "tokenB": "Address of the second token"
        },
        "returns": {
          "amountA": "The actual amount of first token returned",
          "amountB": "The actual amount of second token returned"
        }
      },
      "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
        "details": "Transfers `amountIn` of `path[0]` from `msg.sender` to the contract, calculates the output amount of `path[1]`, transfers `amountOut` to `to` address, updates reserves, and emits a `Swap` event Requires `amountOut` to be at least `amountOutMin`",
        "params": {
          "amountIn": "Amount of input tokens to swap",
          "amountOutMin": "Minimum amount of output tokens to receive, to prevent front-running",
          "deadline": "Maximum timestamp until which the transaction is valid",
          "path": "Array containing [tokenIn, tokenOut] addresses",
          "to": "Address that will receive the output tokens"
        }
      },
      "transferOwnership(address)": {
        "details": "Only the current owner can call this function",
        "params": {
          "newOwner": "The address of the new owner"
        }
      },
      "unpause()": {
        "details": "Only the owner can call this function to resume operations"
      }
    },
    "stateVariables": {
      "liquidityBalances": {
        "details": "Maps pair hash => user address => liquidity balance"
      },
      "pairs": {
        "details": "Uses keccak256(abi.encodePacked(tokenA, tokenB)) as key for deterministic ordering to ensure that a pair (tokenA, tokenB) always maps to the same data regardless of input order"
      }
    },
    "title": "SimpleSwap",
    "version": 1
  },
  "userdoc": {
    "events": {
      "LiquidityAction(address,address,uint256,uint256,uint256,bool)": {
        "notice": "Emitted when liquidity is added or removed from a pair"
      },
      "OwnershipTransferred(address,address)": {
        "notice": "Emitted when ownership is transferred"
      },
      "Paused(address)": {
        "notice": "Emitted when the contract is paused"
      },
      "Swap(address,address,uint256,uint256)": {
        "notice": "Emitted when tokens are swapped"
      },
      "Unpaused(address)": {
        "notice": "Emitted when the contract is unpaused"
      }
    },
    "kind": "user",
    "methods": {
      "_getPairHash(address,address)": {
        "notice": "Internal function to get a deterministic hash for a token pair"
      },
      "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
        "notice": "Adds liquidity to a token pair pool"
      },
      "calculateMinOutputWithSlippage(uint256,address[],uint256)": {
        "notice": "Advanced slippage protection with custom tolerance"
      },
      "constructor": {
        "notice": "Constructor to set the initial owner"
      },
      "estimateSwapGas(uint256,address[])": {
        "notice": "Estimates the gas cost for a swap operation"
      },
      "getAmountOut(uint256,uint256,uint256)": {
        "notice": "Calculates the output amount for a swap given an input amount and current reserves"
      },
      "getPrice(address,address)": {
        "notice": "Gets the current price of tokenA in terms of tokenB"
      },
      "getReserves(address,address)": {
        "notice": "Gets the current reserve amounts for a token pair"
      },
      "liquidityBalances(bytes32,address)": {
        "notice": "Stores liquidity token balances for each user in each pair"
      },
      "owner()": {
        "notice": "Address of the contract owner who can pause/unpause the contract"
      },
      "pairs(bytes32)": {
        "notice": "Maps a deterministic token pair hash to its PairData"
      },
      "pause()": {
        "notice": "Pauses the contract, preventing new swaps and liquidity operations"
      },
      "paused()": {
        "notice": "Flag indicating if the contract is paused for emergency situations"
      },
      "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
        "notice": "Removes liquidity from a token pair pool"
      },
      "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
        "notice": "Swaps an exact amount of input tokens for output tokens"
      },
      "transferOwnership(address)": {
        "notice": "Transfers ownership of the contract to a new account"
      },
      "unpause()": {
        "notice": "Unpauses the contract, allowing normal operations to resume"
      }
    },
    "notice": "An optimized automated market maker (AMM) for token swapping without fees",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 8,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "paused",
        "offset": 20,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 37,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "pairs",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(PairData)18_storage)"
      },
      {
        "astId": 44,
        "contract": "contracts/SimpleSwap.sol:SimpleSwap",
        "label": "liquidityBalances",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_bytes32,t_struct(PairData)18_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct SimpleSwap.PairData)",
        "numberOfBytes": "32",
        "value": "t_struct(PairData)18_storage"
      },
      "t_struct(PairData)18_storage": {
        "encoding": "inplace",
        "label": "struct SimpleSwap.PairData",
        "members": [
          {
            "astId": 11,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "reserveA",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 14,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "reserveB",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 17,
            "contract": "contracts/SimpleSwap.sol:SimpleSwap",
            "label": "totalLiquidity",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}